
<!DOCTYPE html>
<html lang="zh">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>code notes</title>
    <link rel="stylesheet" href="https://melonbo.github.io/css/pylit.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
<div id="container">

    <div class="section" id="section-0">
        <div class="docs doc-strings">

        </div>
        <div class="code">

        </div>
    </div>



    <div class="section" id="section-1">
        <div class="docs doc-strings">

        </div>
        <div class="code">

        </div>
    </div>



    <div class="section" id="section-2">
        <div class="docs doc-strings">

        </div>
        <div class="code">

        </div>
    </div>



    <div class="section" id="section-3">
        <div class="docs doc-strings">

        </div>
        <div class="code">

        </div>
    </div>



</div>
    <script>
        const blockCodeContents = {
            block1 : `\`\`\`python
# vim: expandtab:ts=4:sw=4
import numpy as np


\`\`\`
`,
block2 : `\`\`\`python
class Detection(object):
    """
    This class represents a bounding box detection in a single image.

    Parameters
    ----------
    tlwh : array_like
        Bounding box in format \`(top left x, top left y, width, height)\`.
    confidence : float
        Detector confidence score.
    feature : array_like
        A feature vector that describes the object contained in this image.

    Attributes
    ----------
    tlwh : ndarray
        Bounding box in format \`(top left x, top left y, width, height)\`.
    confidence : ndarray
        Detector confidence score.
    feature : ndarray | NoneType
        A feature vector that describes the object contained in this image.

    """

    def __init__(self, tlwh, confidence, feature):
        self.tlwh = np.asarray(tlwh, dtype=np.float)
        self.confidence = float(confidence)
        self.feature = np.asarray(feature, dtype=np.float32)



\`\`\`
`,
block3 : `\`\`\`
    def to_tlbr(self):
        """Convert bounding box to format \`(min x, min y, max x, max y)\`, i.e.,
        \`(top left, bottom right)\`.
        """
        ret = self.tlwh.copy()
        ret[2:] += ret[:2]
        return ret


\`\`\``,
block4 : `\`\`\`
    def to_xyah(self):
        """Convert bounding box to format \`(center x, center y, aspect ratio,
        height)\`, where the aspect ratio is \`width / height\`.
        """
        ret = self.tlwh.copy()
        ret[:2] += ret[2:] / 2
        ret[2] /= ret[3]
        return ret
\`\`\``
        };

        const blockExplainContents = {
            block1 : `在计算机视觉中，边界框有几种常见表示：

- **TLWH**​ (Top-Left Width-Height): \`(x, y, width, height)\`
    
- **TLBR**​ (Top-Left Bottom-Right): \`(x_min, y_min, x_max, y_max)\`
    
- **XYAH**​ (Center-X Center-Y Aspect-Ratio Height): \`(cx, cy, aspect_ratio, height)\`

### DeepSORT中的数据流

\`\`\`
目标检测器 → Detection对象 → 特征匹配 → 轨迹跟踪
\`\`\`
`,
block2 : `### 构造函数 \`__init__\`


**参数解析**:

- \`tlwh\`: 边界框的TLWH格式 \`[x, y, width, height]\`
    
- \`confidence\`: 检测器置信度分数
    
- \`feature\`: 目标的视觉特征向量`,
block3 : `### 坐标转换方法 \`to_tlbr()\`

**数学原理**:

\`\`\`
TLWH: [x, y, width, height]
TLBR: [x, y, x+width, y+height]
\`\`\`

**转换过程**:

\`\`\`
tlwh = [100, 50, 64, 128]
ret = [100, 50, 64, 128].copy()  # 创建副本避免修改原数据
ret[2:] += ret[:2]               # [64,128] += [100,50] → [164,178]
# 结果: [100, 50, 164, 178] → TLBR格式
\`\`\`

**使用场景**:

- 图像绘制边界框
    
- IoU（交并比）计算
    
- 非极大值抑制（NMS）`,
block4 : `### 坐标转换方法 \`to_xyah()\`


**数学原理**:

\`\`\`
TLWH: [x, y, width, height]
XYAH: [x+width/2, y+height/2, width/height, height]
\`\`\`

**转换过程**:

\`\`\`
# 假设 tlwh = [100, 50, 64, 128]
ret = [100, 50, 64, 128].copy()  # 创建副本
ret[:2] += ret[2:] / 2           # [100,50] += [32,64] → [132,114] (中心点)
ret[2] /= ret[3]                 # 64/128 = 0.5 (宽高比)
# 结果: [132, 114, 0.5, 128] → XYAH格式
\`\`\`

**使用场景**:

- **卡尔曼滤波器**: DeepSORT使用XYAH格式进行运动预测
    
- **状态空间建模**: 更适合描述目标的运动状态`
        };

        const blockCodeContentsSize = Object.keys(blockCodeContents).length;
        window.addEventListener('DOMContentLoaded', function() {
            for (let i = 0; i < blockCodeContentsSize; i++) {
                const elementId = `section-${i}`;
                const blockId = `block${i+1}`;
                const explainBlockId = `explainBlock${i+1}`;
                document.getElementById(elementId).querySelector('.docs').innerHTML = marked.parse(blockCodeContents[blockId]);
                document.getElementById(elementId).querySelector('.code').innerHTML = marked.parse(blockExplainContents[blockId]);
            }
        });

    </script>
        </body>
        </html>