
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>code notes</title>
    <!-- 引入marked.js -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', sans-serif; }
        .page-container { display: flex; width: 100vw; height: 100vh; overflow: hidden; }
        .code-column { width: 45%; height: 100%; background: #1e1e1e; color: #dcdcdc; overflow-y: auto; padding: 20px; border-right: 1px solid #333; }
        .explain-column { width: 55%; height: 100%; background: #f8f9fa; overflow-y: auto; padding: 20px; }
        .code-block, .explain-block { margin-bottom: 30px; padding: 15px; border-radius: 8px; }
        .code-block { background: #2d2d2d; position: relative; }
        .explain-block { background: white; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .code-block h3 { color: #61afef; margin-bottom: 10px; font-size: 16px; }
        .explain-block h3 { color: #2d3748; margin-bottom: 10px; font-size: 16px; }
        .code-content { font-family: 'Consolas', monospace; font-size: 14px; line-height: 1.6; white-space: pre-wrap; }
        .explain-content { color: #4a5568; font-size: 14px; line-height: 1.8; }
        .save-btn { background: transparent; border: none; color: transparent;}
        .code-block.active { border: 2px solid #61afef; }
        .explain-block.active { border-left: 4px solid #61afef; background: #f0f8ff; }
        .header { padding: 10px 20px; background: #333; color: 333; text-align: center; }
        @media (max-width: 768px) { .page-container { flex-direction: column; } .code-column, .explain-column { width: 100%; height: 50%; } }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            border: 1px solid #ddd;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 12px 15px;
            text-align: left;
        }

        th {
            background-color: #3498db;
            color: white;
            font-weight: 600;
        }

        tr:nth-child(even) {
            background-color: #f8f9fa;
        }

        tr:hover {
            background-color: #f1f8ff;
        }

        ul, ol {
            padding-left: 2em; /* 设置左侧缩进距离 */
            margin: 1em 0; /* 上下外边距，增强与其他内容的间距 */
        }

        li {
            margin: 0.5em 0; /* 列表项之间的间距 */
        }

        hr {
            margin: 1.5em 0; /* 上下各1.5em的空白距离 */
            border: none;
            border-top: 1px solid #ddd; /* 分割线样式 */
        }

        /* 代码段样式 */
        .explain-content pre {
            background-color: #1e1e1e; /* 代码块背景色 */
            border-radius: 6px;        /* 圆角 */
            padding: 1em;              /* 内边距 */
            margin: 1em 0;             /* 上下外边距 */
            white-space: pre-wrap;     /* 允许自动换行（保留空白符但允许换行） */
            word-wrap: break-word;     /* 长单词或URL自动换行 */
        }

        .explain-content code {
            font-family: 'Consolas', 'Monaco', monospace; /* 等宽字体 */
            font-size: 13px;           /* 字体大小 */
            line-height: 1.5;          /* 行高 */
            color: #dcdcdc;            /* 默认文字颜色 */
            white-space: inherit;      /* 继承pre的换行设置 */
        }

        .code-content pre,
        .code-content code {
            /* 继承.code-content的样式 */
            background-color: transparent;
            border: none;
            padding: 0;
            color: inherit;
            white-space: pre-wrap;     /* 允许自动换行（保留空白符但允许换行） */
            word-wrap: break-word;     /* 长单词或URL自动换行 */
        }
    </style>
</head>
<body>
    <div class="page-container">
<div class="code-column" id="codeColumn">
        <div class="code-block" data-id="block1" id="block1">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block2" id="block2">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block3" id="block3">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block4" id="block4">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block5" id="block5">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block6" id="block6">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block7" id="block7">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block8" id="block8">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block9" id="block9">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block10" id="block10">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block11" id="block11">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block12" id="block12">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block13" id="block13">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block14" id="block14">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block15" id="block15">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block16" id="block16">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block17" id="block17">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block18" id="block18">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block19" id="block19">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block20" id="block20">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block21" id="block21">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block22" id="block22">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block23" id="block23">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block24" id="block24">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block25" id="block25">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block26" id="block26">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block27" id="block27">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block28" id="block28">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block29" id="block29">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block30" id="block30">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block31" id="block31">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block32" id="block32">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block33" id="block33">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block34" id="block34">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block35" id="block35">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block36" id="block36">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block37" id="block37">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block38" id="block38">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block39" id="block39">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block40" id="block40">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block41" id="block41">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block42" id="block42">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block43" id="block43">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block44" id="block44">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block45" id="block45">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block46" id="block46">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block47" id="block47">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block48" id="block48">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block49" id="block49">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block50" id="block50">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block51" id="block51">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block52" id="block52">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block53" id="block53">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block54" id="block54">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block55" id="block55">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block56" id="block56">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block57" id="block57">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block58" id="block58">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block59" id="block59">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block60" id="block60">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block61" id="block61">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block62" id="block62">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block63" id="block63">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block64" id="block64">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block65" id="block65">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block66" id="block66">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block67" id="block67">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block68" id="block68">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block69" id="block69">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block70" id="block70">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block71" id="block71">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block72" id="block72">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block73" id="block73">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block74" id="block74">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block75" id="block75">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block76" id="block76">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block77" id="block77">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block78" id="block78">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block79" id="block79">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block80" id="block80">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block81" id="block81">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block82" id="block82">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block83" id="block83">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block84" id="block84">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block85" id="block85">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block86" id="block86">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block87" id="block87">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block88" id="block88">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block89" id="block89">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block90" id="block90">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block91" id="block91">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block92" id="block92">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block93" id="block93">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block94" id="block94">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block95" id="block95">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block96" id="block96">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block97" id="block97">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block98" id="block98">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block99" id="block99">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block100" id="block100">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block101" id="block101">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block102" id="block102">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block103" id="block103">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block104" id="block104">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block105" id="block105">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block106" id="block106">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block107" id="block107">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block108" id="block108">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block109" id="block109">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block110" id="block110">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block111" id="block111">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block112" id="block112">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block113" id="block113">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block114" id="block114">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block115" id="block115">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block116" id="block116">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block117" id="block117">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block118" id="block118">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block119" id="block119">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block120" id="block120">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block121" id="block121">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block122" id="block122">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block123" id="block123">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block124" id="block124">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block125" id="block125">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block126" id="block126">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block127" id="block127">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block128" id="block128">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block129" id="block129">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block130" id="block130">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block131" id="block131">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block132" id="block132">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block133" id="block133">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block134" id="block134">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block135" id="block135">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block136" id="block136">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block137" id="block137">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block138" id="block138">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block139" id="block139">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block140" id="block140">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block141" id="block141">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block142" id="block142">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block143" id="block143">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block144" id="block144">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block145" id="block145">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block146" id="block146">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block147" id="block147">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block148" id="block148">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block149" id="block149">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block150" id="block150">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block151" id="block151">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block152" id="block152">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block153" id="block153">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block154" id="block154">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block155" id="block155">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block156" id="block156">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block157" id="block157">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block158" id="block158">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block159" id="block159">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block160" id="block160">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block161" id="block161">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block162" id="block162">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block163" id="block163">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block164" id="block164">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block165" id="block165">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block166" id="block166">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block167" id="block167">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block168" id="block168">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block169" id="block169">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block170" id="block170">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block171" id="block171">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block172" id="block172">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block173" id="block173">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block174" id="block174">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block175" id="block175">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block176" id="block176">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block177" id="block177">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block178" id="block178">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block179" id="block179">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block180" id="block180">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block181" id="block181">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block182" id="block182">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block183" id="block183">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block184" id="block184">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block185" id="block185">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block186" id="block186">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block187" id="block187">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block188" id="block188">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block189" id="block189">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block190" id="block190">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block191" id="block191">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block192" id="block192">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block193" id="block193">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block194" id="block194">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block195" id="block195">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block196" id="block196">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block197" id="block197">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block198" id="block198">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block199" id="block199">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block200" id="block200">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block201" id="block201">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block202" id="block202">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block203" id="block203">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block204" id="block204">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block205" id="block205">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block206" id="block206">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block207" id="block207">
            <div class="code-content"></div>
        </div>

        <div class="code-block" data-id="block208" id="block208">
            <div class="code-content"></div>
        </div>
</div>
<div class="explain-column" id="explainColumn">
        <div class="explain-block" data-id="block1" id="explainBlock1">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block2" id="explainBlock2">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block3" id="explainBlock3">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block4" id="explainBlock4">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block5" id="explainBlock5">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block6" id="explainBlock6">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block7" id="explainBlock7">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block8" id="explainBlock8">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block9" id="explainBlock9">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block10" id="explainBlock10">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block11" id="explainBlock11">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block12" id="explainBlock12">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block13" id="explainBlock13">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block14" id="explainBlock14">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block15" id="explainBlock15">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block16" id="explainBlock16">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block17" id="explainBlock17">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block18" id="explainBlock18">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block19" id="explainBlock19">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block20" id="explainBlock20">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block21" id="explainBlock21">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block22" id="explainBlock22">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block23" id="explainBlock23">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block24" id="explainBlock24">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block25" id="explainBlock25">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block26" id="explainBlock26">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block27" id="explainBlock27">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block28" id="explainBlock28">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block29" id="explainBlock29">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block30" id="explainBlock30">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block31" id="explainBlock31">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block32" id="explainBlock32">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block33" id="explainBlock33">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block34" id="explainBlock34">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block35" id="explainBlock35">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block36" id="explainBlock36">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block37" id="explainBlock37">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block38" id="explainBlock38">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block39" id="explainBlock39">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block40" id="explainBlock40">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block41" id="explainBlock41">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block42" id="explainBlock42">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block43" id="explainBlock43">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block44" id="explainBlock44">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block45" id="explainBlock45">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block46" id="explainBlock46">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block47" id="explainBlock47">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block48" id="explainBlock48">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block49" id="explainBlock49">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block50" id="explainBlock50">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block51" id="explainBlock51">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block52" id="explainBlock52">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block53" id="explainBlock53">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block54" id="explainBlock54">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block55" id="explainBlock55">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block56" id="explainBlock56">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block57" id="explainBlock57">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block58" id="explainBlock58">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block59" id="explainBlock59">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block60" id="explainBlock60">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block61" id="explainBlock61">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block62" id="explainBlock62">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block63" id="explainBlock63">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block64" id="explainBlock64">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block65" id="explainBlock65">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block66" id="explainBlock66">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block67" id="explainBlock67">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block68" id="explainBlock68">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block69" id="explainBlock69">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block70" id="explainBlock70">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block71" id="explainBlock71">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block72" id="explainBlock72">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block73" id="explainBlock73">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block74" id="explainBlock74">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block75" id="explainBlock75">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block76" id="explainBlock76">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block77" id="explainBlock77">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block78" id="explainBlock78">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block79" id="explainBlock79">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block80" id="explainBlock80">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block81" id="explainBlock81">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block82" id="explainBlock82">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block83" id="explainBlock83">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block84" id="explainBlock84">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block85" id="explainBlock85">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block86" id="explainBlock86">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block87" id="explainBlock87">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block88" id="explainBlock88">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block89" id="explainBlock89">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block90" id="explainBlock90">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block91" id="explainBlock91">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block92" id="explainBlock92">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block93" id="explainBlock93">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block94" id="explainBlock94">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block95" id="explainBlock95">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block96" id="explainBlock96">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block97" id="explainBlock97">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block98" id="explainBlock98">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block99" id="explainBlock99">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block100" id="explainBlock100">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block101" id="explainBlock101">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block102" id="explainBlock102">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block103" id="explainBlock103">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block104" id="explainBlock104">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block105" id="explainBlock105">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block106" id="explainBlock106">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block107" id="explainBlock107">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block108" id="explainBlock108">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block109" id="explainBlock109">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block110" id="explainBlock110">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block111" id="explainBlock111">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block112" id="explainBlock112">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block113" id="explainBlock113">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block114" id="explainBlock114">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block115" id="explainBlock115">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block116" id="explainBlock116">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block117" id="explainBlock117">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block118" id="explainBlock118">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block119" id="explainBlock119">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block120" id="explainBlock120">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block121" id="explainBlock121">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block122" id="explainBlock122">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block123" id="explainBlock123">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block124" id="explainBlock124">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block125" id="explainBlock125">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block126" id="explainBlock126">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block127" id="explainBlock127">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block128" id="explainBlock128">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block129" id="explainBlock129">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block130" id="explainBlock130">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block131" id="explainBlock131">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block132" id="explainBlock132">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block133" id="explainBlock133">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block134" id="explainBlock134">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block135" id="explainBlock135">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block136" id="explainBlock136">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block137" id="explainBlock137">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block138" id="explainBlock138">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block139" id="explainBlock139">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block140" id="explainBlock140">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block141" id="explainBlock141">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block142" id="explainBlock142">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block143" id="explainBlock143">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block144" id="explainBlock144">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block145" id="explainBlock145">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block146" id="explainBlock146">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block147" id="explainBlock147">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block148" id="explainBlock148">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block149" id="explainBlock149">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block150" id="explainBlock150">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block151" id="explainBlock151">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block152" id="explainBlock152">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block153" id="explainBlock153">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block154" id="explainBlock154">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block155" id="explainBlock155">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block156" id="explainBlock156">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block157" id="explainBlock157">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block158" id="explainBlock158">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block159" id="explainBlock159">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block160" id="explainBlock160">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block161" id="explainBlock161">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block162" id="explainBlock162">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block163" id="explainBlock163">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block164" id="explainBlock164">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block165" id="explainBlock165">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block166" id="explainBlock166">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block167" id="explainBlock167">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block168" id="explainBlock168">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block169" id="explainBlock169">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block170" id="explainBlock170">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block171" id="explainBlock171">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block172" id="explainBlock172">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block173" id="explainBlock173">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block174" id="explainBlock174">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block175" id="explainBlock175">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block176" id="explainBlock176">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block177" id="explainBlock177">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block178" id="explainBlock178">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block179" id="explainBlock179">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block180" id="explainBlock180">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block181" id="explainBlock181">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block182" id="explainBlock182">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block183" id="explainBlock183">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block184" id="explainBlock184">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block185" id="explainBlock185">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block186" id="explainBlock186">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block187" id="explainBlock187">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block188" id="explainBlock188">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block189" id="explainBlock189">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block190" id="explainBlock190">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block191" id="explainBlock191">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block192" id="explainBlock192">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block193" id="explainBlock193">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block194" id="explainBlock194">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block195" id="explainBlock195">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block196" id="explainBlock196">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block197" id="explainBlock197">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block198" id="explainBlock198">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block199" id="explainBlock199">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block200" id="explainBlock200">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block201" id="explainBlock201">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block202" id="explainBlock202">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block203" id="explainBlock203">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block204" id="explainBlock204">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block205" id="explainBlock205">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block206" id="explainBlock206">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block207" id="explainBlock207">
            <div class="explain-content"></div>
        </div>

        <div class="explain-block" data-id="block208" id="explainBlock208">
            <div class="explain-content"></div>
        </div>
    </div>
</div>
    <script>
        const blockCodeContents = {
            block1 : `### block 1 : 1 - 72

\`\`\`cpp
/*
Original code by Lee Thomason (www.grinninglizard.com)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any
damages arising from the use of this software.

Permission is granted to anyone to use this software for any
purpose, including commercial applications, and to alter it and
redistribute it freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must
not claim that you wrote the original software. If you use this
software in a product, an acknowledgment in the product documentation
would be appreciated but is not required.

2. Altered source versions must be plainly marked as such, and
must not be misrepresented as being the original software.

3. This notice may not be removed or altered from any source
distribution.
*/

#include "tinyxml2.h"

#include <new>		// yes, this one new style header, is in the Android SDK.
#if defined(ANDROID_NDK) || defined(__BORLANDC__) || defined(__QNXNTO__) || defined(__CC_ARM)
#   include <stddef.h>
#   include <stdarg.h>
#else
#   include <cstddef>
#   include <cstdarg>
#endif

// Handle fallthrough attribute for different compilers
#ifndef __has_attribute
#   define __has_attribute(x) 0
#endif
#ifndef __has_cpp_attribute
#  define __has_cpp_attribute(x) 0
#endif

#if defined(_MSC_VER)
#   define TIXML_FALLTHROUGH (void(0))
#elif (__cplusplus >= 201703L && __has_cpp_attribute(fallthrough))
#   define TIXML_FALLTHROUGH [[fallthrough]]
#elif __has_cpp_attribute(clang::fallthrough)
#   define TIXML_FALLTHROUGH [[clang::fallthrough]]
#elif __has_attribute(fallthrough)
#   define TIXML_FALLTHROUGH __attribute__((fallthrough))
#else
#   define TIXML_FALLTHROUGH (void(0))
#endif


#if defined(_MSC_VER) && (_MSC_VER >= 1400 ) && (!defined WINCE)
	// Microsoft Visual Studio, version 2005 and higher. Not WinCE.
	/*int _snprintf_s(
	   char *buffer,
	   size_t sizeOfBuffer,
	   size_t count,
	   const char *format [,
		  argument] ...
	);*/
	static inline int TIXML_SNPRINTF( char* buffer, size_t size, const char* format, ... )
	{
		va_list va;
		va_start( va, format );
		const int result = vsnprintf_s( buffer, size, _TRUNCATE, format, va );
		va_end( va );
		return result;
	}
\`\`\`
`,
block2 : `### block 2 : 74 - 78

\`\`\`cpp
	static inline int TIXML_VSNPRINTF( char* buffer, size_t size, const char* format, va_list va )
	{
		const int result = vsnprintf_s( buffer, size, _TRUNCATE, format, va );
		return result;
	}
\`\`\`
`,
block3 : `### block 3 : 80 - 108

\`\`\`cpp
	#define TIXML_VSCPRINTF	_vscprintf
	#define TIXML_SSCANF	sscanf_s
#elif defined _MSC_VER
	// Microsoft Visual Studio 2003 and earlier or WinCE
	#define TIXML_SNPRINTF	_snprintf
	#define TIXML_VSNPRINTF _vsnprintf
	#define TIXML_SSCANF	sscanf
	#if (_MSC_VER < 1400 ) && (!defined WINCE)
		// Microsoft Visual Studio 2003 and not WinCE.
		#define TIXML_VSCPRINTF   _vscprintf // VS2003's C runtime has this, but VC6 C runtime or WinCE SDK doesn't have.
	#else
		// Microsoft Visual Studio 2003 and earlier or WinCE.
		static inline int TIXML_VSCPRINTF( const char* format, va_list va )
		{
			int len = 512;
			for (;;) {
				len = len*2;
				char* str = new char[len]();
				const int required = _vsnprintf(str, len, format, va);
				delete[] str;
				if ( required != -1 ) {
					TIXMLASSERT( required >= 0 );
					len = required;
					break;
				}
			}
			TIXMLASSERT( len >= 0 );
			return len;
		}
	#endif
#else
\`\`\`
`,
block4 : `### block 4 : 109 - 120

\`\`\`cpp
	// GCC version 3 and higher
	//#warning( "Using sn* functions." )
	#define TIXML_SNPRINTF	snprintf
	#define TIXML_VSNPRINTF	vsnprintf
	static inline int TIXML_VSCPRINTF( const char* format, va_list va )
	{
		int len = vsnprintf( 0, 0, format, va );
		TIXMLASSERT( len >= 0 );
		return len;
	}
\`\`\`
`,
block5 : `### block 5 : 121 - 161

\`\`\`cpp
	#define TIXML_SSCANF   sscanf
#endif

#if defined(_WIN64)
	#define TIXML_FSEEK _fseeki64
	#define TIXML_FTELL _ftelli64
#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__DragonFly__) || defined(__CYGWIN__)
	#define TIXML_FSEEK fseeko
	#define TIXML_FTELL ftello
#elif defined(__ANDROID__) && __ANDROID_API__ > 24
	#define TIXML_FSEEK fseeko64
	#define TIXML_FTELL ftello64
#else
	#define TIXML_FSEEK fseek
	#define TIXML_FTELL ftell
#endif


static const char LINE_FEED				= static_cast<char>(0x0a);			// all line endings are normalized to LF
static const char LF = LINE_FEED;
static const char CARRIAGE_RETURN		= static_cast<char>(0x0d);			// CR gets filtered out
static const char CR = CARRIAGE_RETURN;
static const char SINGLE_QUOTE			= '\'';
static const char DOUBLE_QUOTE			= '\"';

// Bunch of unicode info at:
//		http://www.unicode.org/faq/utf_bom.html
//	ef bb bf (Microsoft "lead bytes") - designates UTF-8

static const unsigned char TIXML_UTF_LEAD_0 = 0xefU;
static const unsigned char TIXML_UTF_LEAD_1 = 0xbbU;
static const unsigned char TIXML_UTF_LEAD_2 = 0xbfU;

namespace tinyxml2
{

struct Entity {
    const char* pattern;
    int length;
    char value;
};
\`\`\`
`,
block6 : `### block 6 : 163 - 170

\`\`\`cpp
static const int NUM_ENTITIES = 5;
static const Entity entities[NUM_ENTITIES] = {
    { "quot", 4,	DOUBLE_QUOTE },
    { "amp", 3,		'&'  },
    { "apos", 4,	SINGLE_QUOTE },
    { "lt",	2, 		'<'	 },
    { "gt",	2,		'>'	 }
};
\`\`\`
`,
block7 : `### block 7 : 173 - 176

\`\`\`cpp
StrPair::~StrPair()
{
    Reset();
}
\`\`\`
`,
block8 : `### block 8 : 179 - 201

\`\`\`cpp
void StrPair::TransferTo( StrPair* other )
{
    if ( this == other ) {
        return;
    }
    // This in effect implements the assignment operator by "moving"
    // ownership (as in auto_ptr).

    TIXMLASSERT( other != 0 );
    TIXMLASSERT( other->_flags == 0 );
    TIXMLASSERT( other->_start == 0 );
    TIXMLASSERT( other->_end == 0 );

    other->Reset();

    other->_flags = _flags;
    other->_start = _start;
    other->_end = _end;

    _flags = 0;
    _start = 0;
    _end = 0;
}
\`\`\`
`,
block9 : `### block 9 : 204 - 212

\`\`\`cpp
void StrPair::Reset()
{
    if ( _flags & NEEDS_DELETE ) {
        delete [] _start;
    }
    _flags = 0;
    _start = 0;
    _end = 0;
}
\`\`\`
`,
block10 : `### block 10 : 215 - 225

\`\`\`cpp
void StrPair::SetStr( const char* str, int flags )
{
    TIXMLASSERT( str );
    Reset();
    size_t len = strlen( str );
    TIXMLASSERT( _start == 0 );
    _start = new char[ len+1 ];
    memcpy( _start, str, len+1 );
    _end = _start + len;
    _flags = flags | NEEDS_DELETE;
}
\`\`\`
`,
block11 : `### block 11 : 228 - 250

\`\`\`cpp
char* StrPair::ParseText( char* p, const char* endTag, int strFlags, int* curLineNumPtr )
{
    TIXMLASSERT( p );
    TIXMLASSERT( endTag && *endTag );
	TIXMLASSERT(curLineNumPtr);

    char* start = p;
    const char  endChar = *endTag;
    size_t length = strlen( endTag );

    // Inner loop of text parsing.
    while ( *p ) {
        if ( *p == endChar && strncmp( p, endTag, length ) == 0 ) {
            Set( start, p, strFlags );
            return p + length;
        } else if (*p == '\n') {
            ++(*curLineNumPtr);
        }
        ++p;
        TIXMLASSERT( p );
    }
    return 0;
}
\`\`\`
`,
block12 : `### block 12 : 253 - 270

\`\`\`cpp
char* StrPair::ParseName( char* p )
{
    if ( !p || !(*p) ) {
        return 0;
    }
    if ( !XMLUtil::IsNameStartChar( static_cast<unsigned char>(*p) ) ) {
        return 0;
    }

    char* const start = p;
    ++p;
    while ( *p && XMLUtil::IsNameChar( static_cast<unsigned char>(*p) ) ) {
        ++p;
    }

    Set( start, p, 0 );
    return p;
}
\`\`\`
`,
block13 : `### block 13 : 273 - 299

\`\`\`cpp
void StrPair::CollapseWhitespace()
{
    // Adjusting _start would cause undefined behavior on delete[]
    TIXMLASSERT( ( _flags & NEEDS_DELETE ) == 0 );
    // Trim leading space.
    _start = XMLUtil::SkipWhiteSpace( _start, 0 );

    if ( *_start ) {
        const char* p = _start;	// the read pointer
        char* q = _start;	// the write pointer

        while( *p ) {
            if ( XMLUtil::IsWhiteSpace( *p )) {
                p = XMLUtil::SkipWhiteSpace( p, 0 );
                if ( *p == 0 ) {
                    break;    // don't write to q; this trims the trailing space.
                }
                *q = ' ';
                ++q;
            }
            *q = *p;
            ++q;
            ++p;
        }
        *q = 0;
    }
}
\`\`\`
`,
block14 : `### block 14 : 302 - 400

\`\`\`cpp
const char* StrPair::GetStr()
{
    TIXMLASSERT( _start );
    TIXMLASSERT( _end );
    if ( _flags & NEEDS_FLUSH ) {
        *_end = 0;
        _flags ^= NEEDS_FLUSH;

        if ( _flags ) {
            const char* p = _start;	// the read pointer
            char* q = _start;	// the write pointer

            while( p < _end ) {
                if ( (_flags & NEEDS_NEWLINE_NORMALIZATION) && *p == CR ) {
                    // CR-LF pair becomes LF
                    // CR alone becomes LF
                    // LF-CR becomes LF
                    if ( *(p+1) == LF ) {
                        p += 2;
                    }
                    else {
                        ++p;
                    }
                    *q = LF;
                    ++q;
                }
                else if ( (_flags & NEEDS_NEWLINE_NORMALIZATION) && *p == LF ) {
                    if ( *(p+1) == CR ) {
                        p += 2;
                    }
                    else {
                        ++p;
                    }
                    *q = LF;
                    ++q;
                }
                else if ( (_flags & NEEDS_ENTITY_PROCESSING) && *p == '&' ) {
                    // Entities handled by tinyXML2:
                    // - special entities in the entity table [in/out]
                    // - numeric character reference [in]
                    //   &#20013; or &#x4e2d;

                    if ( *(p+1) == '#' ) {
                        const int buflen = 10;
                        char buf[buflen] = { 0 };
                        int len = 0;
                        const char* adjusted = const_cast<char*>( XMLUtil::GetCharacterRef( p, buf, &len ) );
                        if ( adjusted == 0 ) {
                            *q = *p;
                            ++p;
                            ++q;
                        }
                        else {
                            TIXMLASSERT( 0 <= len && len <= buflen );
                            TIXMLASSERT( q + len <= adjusted );
                            p = adjusted;
                            memcpy( q, buf, len );
                            q += len;
                        }
                    }
                    else {
                        bool entityFound = false;
                        for( int i = 0; i < NUM_ENTITIES; ++i ) {
                            const Entity& entity = entities[i];
                            if ( strncmp( p + 1, entity.pattern, entity.length ) == 0
                                    && *( p + entity.length + 1 ) == ';' ) {
                                // Found an entity - convert.
                                *q = entity.value;
                                ++q;
                                p += entity.length + 2;
                                entityFound = true;
                                break;
                            }
                        }
                        if ( !entityFound ) {
                            // fixme: treat as error?
                            ++p;
                            ++q;
                        }
                    }
                }
                else {
                    *q = *p;
                    ++p;
                    ++q;
                }
            }
            *q = 0;
        }
        // The loop below has plenty going on, and this
        // is a less useful mode. Break it out.
        if ( _flags & NEEDS_WHITESPACE_COLLAPSING ) {
            CollapseWhitespace();
        }
        _flags = (_flags & NEEDS_DELETE);
    }
    TIXMLASSERT( _start );
    return _start;
}
\`\`\`
`,
block15 : `### block 15 : 405 - 417

\`\`\`cpp
// --------- XMLUtil ----------- //

const char* XMLUtil::writeBoolTrue  = "true";
const char* XMLUtil::writeBoolFalse = "false";

void XMLUtil::SetBoolSerialization(const char* writeTrue, const char* writeFalse)
{
	static const char* defTrue  = "true";
	static const char* defFalse = "false";

	writeBoolTrue = (writeTrue) ? writeTrue : defTrue;
	writeBoolFalse = (writeFalse) ? writeFalse : defFalse;
}
\`\`\`
`,
block16 : `### block 16 : 420 - 435

\`\`\`cpp
const char* XMLUtil::ReadBOM( const char* p, bool* bom )
{
    TIXMLASSERT( p );
    TIXMLASSERT( bom );
    *bom = false;
    const unsigned char* pu = reinterpret_cast<const unsigned char*>(p);
    // Check for BOM:
    if (    *(pu+0) == TIXML_UTF_LEAD_0
            && *(pu+1) == TIXML_UTF_LEAD_1
            && *(pu+2) == TIXML_UTF_LEAD_2 ) {
        *bom = true;
        p += 3;
    }
    TIXMLASSERT( p );
    return p;
}
\`\`\`
`,
block17 : `### block 17 : 438 - 488

\`\`\`cpp
void XMLUtil::ConvertUTF32ToUTF8( unsigned long input, char* output, int* length )
{
    const unsigned long BYTE_MASK = 0xBF;
    const unsigned long BYTE_MARK = 0x80;
    const unsigned long FIRST_BYTE_MARK[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };

    if (input < 0x80) {
        *length = 1;
    }
    else if ( input < 0x800 ) {
        *length = 2;
    }
    else if ( input < 0x10000 ) {
        *length = 3;
    }
    else if ( input < 0x200000 ) {
        *length = 4;
    }
    else {
        *length = 0;    // This code won't convert this correctly anyway.
        return;
    }

    output += *length;

    // Scary scary fall throughs are annotated with carefully designed comments
    // to suppress compiler warnings such as -Wimplicit-fallthrough in gcc
    switch (*length) {
        case 4:
            --output;
            *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);
            input >>= 6;
            TIXML_FALLTHROUGH;
        case 3:
            --output;
            *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);
            input >>= 6;
            TIXML_FALLTHROUGH;
        case 2:
            --output;
            *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);
            input >>= 6;
            TIXML_FALLTHROUGH;
        case 1:
            --output;
            *output = static_cast<char>(input | FIRST_BYTE_MARK[*length]);
            break;
        default:
            TIXMLASSERT( false );
    }
}
\`\`\`
`,
block18 : `### block 18 : 491 - 577

\`\`\`cpp
const char* XMLUtil::GetCharacterRef(const char* p, char* value, int* length)
{
    // Assume an entity, and pull it out.
    *length = 0;

    static const uint32_t MAX_CODE_POINT = 0x10FFFF;

    if (*(p + 1) == '#' && *(p + 2)) {
        uint32_t ucs = 0;
        ptrdiff_t delta = 0;
        uint32_t mult = 1;
        static const char SEMICOLON = ';';

        bool hex = false;
        uint32_t radix = 10;
        const char* q = 0;
        char terminator = '#';

        if (*(p + 2) == 'x') {
            // Hexadecimal.
            hex = true;
            radix = 16;
            terminator = 'x';

            q = p + 3;
        }
        else {
            // Decimal.
            q = p + 2;
        }
        if (!(*q)) {
            return 0;
        }

        q = strchr(q, SEMICOLON);
        if (!q) {
            return 0;
        }
        TIXMLASSERT(*q == SEMICOLON);

        delta = q - p;
        --q;

        while (*q != terminator) {
            uint32_t digit = 0;

            if (*q >= '0' && *q <= '9') {
                digit = *q - '0';
            }
            else if (hex && (*q >= 'a' && *q <= 'f')) {
                digit = *q - 'a' + 10;
            }
            else if (hex && (*q >= 'A' && *q <= 'F')) {
                digit = *q - 'A' + 10;
            }
            else {
                return 0;
            }
            TIXMLASSERT(digit < radix);

            const unsigned int digitScaled = mult * digit;
            ucs += digitScaled;
            mult *= radix;       
            
            // Security check: could a value exist that is out of range?
            // Easily; limit to the MAX_CODE_POINT, which also allows for a
            // bunch of leading zeroes.
            if (mult > MAX_CODE_POINT) {
                mult = MAX_CODE_POINT;
            }
            --q;
        }
        // Out of range:
        if (ucs > MAX_CODE_POINT) {
            return 0;
        }
        // convert the UCS to UTF-8
        ConvertUTF32ToUTF8(ucs, value, length);
		if (length == 0) {
            // If length is 0, there was an error. (Security? Bad input?)
            // Fail safely.
			return 0;
		}
        return p + delta + 1;
    }
    return p + 1;
}
\`\`\`
`,
block19 : `### block 19 : 579 - 582

\`\`\`cpp
void XMLUtil::ToStr( int v, char* buffer, int bufferSize )
{
    TIXML_SNPRINTF( buffer, bufferSize, "%d", v );
}
\`\`\`
`,
block20 : `### block 20 : 585 - 588

\`\`\`cpp
void XMLUtil::ToStr( unsigned v, char* buffer, int bufferSize )
{
    TIXML_SNPRINTF( buffer, bufferSize, "%u", v );
}
\`\`\`
`,
block21 : `### block 21 : 591 - 594

\`\`\`cpp
void XMLUtil::ToStr( bool v, char* buffer, int bufferSize )
{
    TIXML_SNPRINTF( buffer, bufferSize, "%s", v ? writeBoolTrue : writeBoolFalse);
}
\`\`\`
`,
block22 : `### block 22 : 596 - 603

\`\`\`cpp
/*
	ToStr() of a number is a very tricky topic.
	https://github.com/leethomason/tinyxml2/issues/106
*/
void XMLUtil::ToStr( float v, char* buffer, int bufferSize )
{
    TIXML_SNPRINTF( buffer, bufferSize, "%.8g", v );
}
\`\`\`
`,
block23 : `### block 23 : 606 - 609

\`\`\`cpp
void XMLUtil::ToStr( double v, char* buffer, int bufferSize )
{
    TIXML_SNPRINTF( buffer, bufferSize, "%.17g", v );
}
\`\`\`
`,
block24 : `### block 24 : 612 - 616

\`\`\`cpp
void XMLUtil::ToStr( int64_t v, char* buffer, int bufferSize )
{
	// horrible syntax trick to make the compiler happy about %lld
	TIXML_SNPRINTF(buffer, bufferSize, "%lld", static_cast<long long>(v));
}
\`\`\`
`,
block25 : `### block 25 : 618 - 622

\`\`\`cpp
void XMLUtil::ToStr( uint64_t v, char* buffer, int bufferSize )
{
    // horrible syntax trick to make the compiler happy about %llu
    TIXML_SNPRINTF(buffer, bufferSize, "%llu", static_cast<unsigned long long>(v));
}
\`\`\`
`,
block26 : `### block 26 : 624 - 639

\`\`\`cpp
bool XMLUtil::ToInt(const char* str, int* value)
{
    if (IsPrefixHex(str)) {
        unsigned v;
        if (TIXML_SSCANF(str, "%x", &v) == 1) {
            *value = static_cast<int>(v);
            return true;
        }
    }
    else {
        if (TIXML_SSCANF(str, "%d", value) == 1) {
            return true;
        }
    }
    return false;
}
\`\`\`
`,
block27 : `### block 27 : 641 - 647

\`\`\`cpp
bool XMLUtil::ToUnsigned(const char* str, unsigned* value)
{
    if (TIXML_SSCANF(str, IsPrefixHex(str) ? "%x" : "%u", value) == 1) {
        return true;
    }
    return false;
}
\`\`\`
`,
block28 : `### block 28 : 649 - 672

\`\`\`cpp
bool XMLUtil::ToBool( const char* str, bool* value )
{
    int ival = 0;
    if ( ToInt( str, &ival )) {
        *value = (ival==0) ? false : true;
        return true;
    }
    static const char* TRUE_VALS[] = { "true", "True", "TRUE", 0 };
    static const char* FALSE_VALS[] = { "false", "False", "FALSE", 0 };

    for (int i = 0; TRUE_VALS[i]; ++i) {
        if (StringEqual(str, TRUE_VALS[i])) {
            *value = true;
            return true;
        }
    }
    for (int i = 0; FALSE_VALS[i]; ++i) {
        if (StringEqual(str, FALSE_VALS[i])) {
            *value = false;
            return true;
        }
    }
    return false;
}
\`\`\`
`,
block29 : `### block 29 : 675 - 681

\`\`\`cpp
bool XMLUtil::ToFloat( const char* str, float* value )
{
    if ( TIXML_SSCANF( str, "%f", value ) == 1 ) {
        return true;
    }
    return false;
}
\`\`\`
`,
block30 : `### block 30 : 684 - 690

\`\`\`cpp
bool XMLUtil::ToDouble( const char* str, double* value )
{
    if ( TIXML_SSCANF( str, "%lf", value ) == 1 ) {
        return true;
    }
    return false;
}
\`\`\`
`,
block31 : `### block 31 : 693 - 710

\`\`\`cpp
bool XMLUtil::ToInt64(const char* str, int64_t* value)
{
    if (IsPrefixHex(str)) {
        unsigned long long v = 0;	// horrible syntax trick to make the compiler happy about %llx
        if (TIXML_SSCANF(str, "%llx", &v) == 1) {
            *value = static_cast<int64_t>(v);
            return true;
        }
    }
    else {
        long long v = 0;	// horrible syntax trick to make the compiler happy about %lld
        if (TIXML_SSCANF(str, "%lld", &v) == 1) {
            *value = static_cast<int64_t>(v);
            return true;
        }
    }
	return false;
}
\`\`\`
`,
block32 : `### block 32 : 713 - 720

\`\`\`cpp
bool XMLUtil::ToUnsigned64(const char* str, uint64_t* value) {
    unsigned long long v = 0;	// horrible syntax trick to make the compiler happy about %llu
    if(TIXML_SSCANF(str, IsPrefixHex(str) ? "%llx" : "%llu", &v) == 1) {
        *value = static_cast<uint64_t>(v);
        return true;
    }
    return false;
}
\`\`\`
`,
block33 : `### block 33 : 723 - 800

\`\`\`cpp
char* XMLDocument::Identify( char* p, XMLNode** node, bool first )
{
    TIXMLASSERT( node );
    TIXMLASSERT( p );
    char* const start = p;
    int const startLine = _parseCurLineNum;
    p = XMLUtil::SkipWhiteSpace( p, &_parseCurLineNum );
    if( !*p ) {
        *node = 0;
        TIXMLASSERT( p );
        return p;
    }

    // These strings define the matching patterns:
    static const char* xmlHeader		= { "<?" };
    static const char* commentHeader	= { "<!--" };
    static const char* cdataHeader		= { "<![CDATA[" };
    static const char* dtdHeader		= { "<!" };
    static const char* elementHeader	= { "<" };	// and a header for everything else; check last.

    static const int xmlHeaderLen		= 2;
    static const int commentHeaderLen	= 4;
    static const int cdataHeaderLen		= 9;
    static const int dtdHeaderLen		= 2;
    static const int elementHeaderLen	= 1;

    TIXMLASSERT( sizeof( XMLComment ) == sizeof( XMLUnknown ) );		// use same memory pool
    TIXMLASSERT( sizeof( XMLComment ) == sizeof( XMLDeclaration ) );	// use same memory pool
    XMLNode* returnNode = 0;
    if ( XMLUtil::StringEqual( p, xmlHeader, xmlHeaderLen ) ) {
        returnNode = CreateUnlinkedNode<XMLDeclaration>( _commentPool );
        returnNode->_parseLineNum = _parseCurLineNum;
        p += xmlHeaderLen;
    }
    else if ( XMLUtil::StringEqual( p, commentHeader, commentHeaderLen ) ) {
        returnNode = CreateUnlinkedNode<XMLComment>( _commentPool );
        returnNode->_parseLineNum = _parseCurLineNum;
        p += commentHeaderLen;
    }
    else if ( XMLUtil::StringEqual( p, cdataHeader, cdataHeaderLen ) ) {
        XMLText* text = CreateUnlinkedNode<XMLText>( _textPool );
        returnNode = text;
        returnNode->_parseLineNum = _parseCurLineNum;
        p += cdataHeaderLen;
        text->SetCData( true );
    }
    else if ( XMLUtil::StringEqual( p, dtdHeader, dtdHeaderLen ) ) {
        returnNode = CreateUnlinkedNode<XMLUnknown>( _commentPool );
        returnNode->_parseLineNum = _parseCurLineNum;
        p += dtdHeaderLen;
    }
    else if ( XMLUtil::StringEqual( p, elementHeader, elementHeaderLen ) ) {

        // Preserve whitespace pedantically before closing tag, when it's immediately after opening tag
        if (WhitespaceMode() == PEDANTIC_WHITESPACE && first && p != start && *(p + elementHeaderLen) == '/') {
            returnNode = CreateUnlinkedNode<XMLText>(_textPool);
            returnNode->_parseLineNum = startLine;
            p = start;	// Back it up, all the text counts.
            _parseCurLineNum = startLine;
        }
        else {
            returnNode = CreateUnlinkedNode<XMLElement>(_elementPool);
            returnNode->_parseLineNum = _parseCurLineNum;
            p += elementHeaderLen;
        }
    }
    else {
        returnNode = CreateUnlinkedNode<XMLText>( _textPool );
        returnNode->_parseLineNum = _parseCurLineNum; // Report line of first non-whitespace character
        p = start;	// Back it up, all the text counts.
        _parseCurLineNum = startLine;
    }

    TIXMLASSERT( returnNode );
    TIXMLASSERT( p );
    *node = returnNode;
    return p;
}
\`\`\`
`,
block34 : `### block 34 : 803 - 814

\`\`\`cpp
bool XMLDocument::Accept( XMLVisitor* visitor ) const
{
    TIXMLASSERT( visitor );
    if ( visitor->VisitEnter( *this ) ) {
        for ( const XMLNode* node=FirstChild(); node; node=node->NextSibling() ) {
            if ( !node->Accept( visitor ) ) {
                break;
            }
        }
    }
    return visitor->VisitExit( *this );
}
\`\`\`
`,
block35 : `### block 35 : 817 - 829

\`\`\`cpp
// --------- XMLNode ----------- //

XMLNode::XMLNode( XMLDocument* doc ) :
    _document( doc ),
    _parent( 0 ),
    _value(),
    _parseLineNum( 0 ),
    _firstChild( 0 ), _lastChild( 0 ),
    _prev( 0 ), _next( 0 ),
	_userData( 0 ),
    _memPool( 0 )
{
}
\`\`\`
`,
block36 : `### block 36 : 832 - 838

\`\`\`cpp
XMLNode::~XMLNode()
{
    DeleteChildren();
    if ( _parent ) {
        _parent->Unlink( this );
    }
}
\`\`\`
`,
block37 : `### block 37 : 840 - 853

\`\`\`cpp
// ChildElementCount was originally suggested by msteiger on the sourceforge page for TinyXML and modified by KB1SPH for TinyXML-2.

int XMLNode::ChildElementCount(const char *value) const {
	int count = 0;

	const XMLElement *e = FirstChildElement(value);

	while (e) {
		e = e->NextSiblingElement(value);
		count++;
	}

	return count;
}
\`\`\`
`,
block38 : `### block 38 : 855 - 866

\`\`\`cpp
int XMLNode::ChildElementCount() const {
	int count = 0;

	const XMLElement *e = FirstChildElement();

	while (e) {
		e = e->NextSiblingElement();
		count++;
	}

	return count;
}
\`\`\`
`,
block39 : `### block 39 : 868 - 874

\`\`\`cpp
const char* XMLNode::Value() const
{
    // Edge case: XMLDocuments don't have a Value. Return null.
    if ( this->ToDocument() )
        return 0;
    return _value.GetStr();
}
\`\`\`
`,
block40 : `### block 40 : 876 - 884

\`\`\`cpp
void XMLNode::SetValue( const char* str, bool staticMem )
{
    if ( staticMem ) {
        _value.SetInternedStr( str );
    }
    else {
        _value.SetStr( str );
    }
}
\`\`\`
`,
block41 : `### block 41 : 886 - 897

\`\`\`cpp
XMLNode* XMLNode::DeepClone(XMLDocument* target) const
{
	XMLNode* clone = this->ShallowClone(target);
	if (!clone) return 0;

	for (const XMLNode* child = this->FirstChild(); child; child = child->NextSibling()) {
		XMLNode* childClone = child->DeepClone(target);
		TIXMLASSERT(childClone);
		clone->InsertEndChild(childClone);
	}
	return clone;
}
\`\`\`
`,
block42 : `### block 42 : 899 - 906

\`\`\`cpp
void XMLNode::DeleteChildren()
{
    while( _firstChild ) {
        TIXMLASSERT( _lastChild );
        DeleteChild( _firstChild );
    }
    _firstChild = _lastChild = 0;
}
\`\`\`
`,
block43 : `### block 43 : 909 - 930

\`\`\`cpp
void XMLNode::Unlink( XMLNode* child )
{
    TIXMLASSERT( child );
    TIXMLASSERT( child->_document == _document );
    TIXMLASSERT( child->_parent == this );
    if ( child == _firstChild ) {
        _firstChild = _firstChild->_next;
    }
    if ( child == _lastChild ) {
        _lastChild = _lastChild->_prev;
    }

    if ( child->_prev ) {
        child->_prev->_next = child->_next;
    }
    if ( child->_next ) {
        child->_next->_prev = child->_prev;
    }
	child->_next = 0;
	child->_prev = 0;
	child->_parent = 0;
}
\`\`\`
`,
block44 : `### block 44 : 933 - 943

\`\`\`cpp
void XMLNode::DeleteChild( XMLNode* node )
{
    TIXMLASSERT( node );
    TIXMLASSERT( node->_document == _document );
    TIXMLASSERT( node->_parent == this );
    Unlink( node );
	TIXMLASSERT(node->_prev == 0);
	TIXMLASSERT(node->_next == 0);
	TIXMLASSERT(node->_parent == 0);
    DeleteNode( node );
}
\`\`\`
`,
block45 : `### block 45 : 946 - 973

\`\`\`cpp
XMLNode* XMLNode::InsertEndChild( XMLNode* addThis )
{
    TIXMLASSERT( addThis );
    if ( addThis->_document != _document ) {
        TIXMLASSERT( false );
        return 0;
    }
    InsertChildPreamble( addThis );

    if ( _lastChild ) {
        TIXMLASSERT( _firstChild );
        TIXMLASSERT( _lastChild->_next == 0 );
        _lastChild->_next = addThis;
        addThis->_prev = _lastChild;
        _lastChild = addThis;

        addThis->_next = 0;
    }
    else {
        TIXMLASSERT( _firstChild == 0 );
        _firstChild = _lastChild = addThis;

        addThis->_prev = 0;
        addThis->_next = 0;
    }
    addThis->_parent = this;
    return addThis;
}
\`\`\`
`,
block46 : `### block 46 : 976 - 1004

\`\`\`cpp
XMLNode* XMLNode::InsertFirstChild( XMLNode* addThis )
{
    TIXMLASSERT( addThis );
    if ( addThis->_document != _document ) {
        TIXMLASSERT( false );
        return 0;
    }
    InsertChildPreamble( addThis );

    if ( _firstChild ) {
        TIXMLASSERT( _lastChild );
        TIXMLASSERT( _firstChild->_prev == 0 );

        _firstChild->_prev = addThis;
        addThis->_next = _firstChild;
        _firstChild = addThis;

        addThis->_prev = 0;
    }
    else {
        TIXMLASSERT( _lastChild == 0 );
        _firstChild = _lastChild = addThis;

        addThis->_prev = 0;
        addThis->_next = 0;
    }
    addThis->_parent = this;
    return addThis;
}
\`\`\`
`,
block47 : `### block 47 : 1007 - 1040

\`\`\`cpp
XMLNode* XMLNode::InsertAfterChild( XMLNode* afterThis, XMLNode* addThis )
{
    TIXMLASSERT( addThis );
    if ( addThis->_document != _document ) {
        TIXMLASSERT( false );
        return 0;
    }

    TIXMLASSERT( afterThis );

    if ( afterThis->_parent != this ) {
        TIXMLASSERT( false );
        return 0;
    }
    if ( afterThis == addThis ) {
        // Current state: BeforeThis -> AddThis -> OneAfterAddThis
        // Now AddThis must disappear from it's location and then
        // reappear between BeforeThis and OneAfterAddThis.
        // So just leave it where it is.
        return addThis;
    }

    if ( afterThis->_next == 0 ) {
        // The last node or the only node.
        return InsertEndChild( addThis );
    }
    InsertChildPreamble( addThis );
    addThis->_prev = afterThis;
    addThis->_next = afterThis->_next;
    afterThis->_next->_prev = addThis;
    afterThis->_next = addThis;
    addThis->_parent = this;
    return addThis;
}
\`\`\`
`,
block48 : `### block 48 : 1045 - 1054

\`\`\`cpp
const XMLElement* XMLNode::FirstChildElement( const char* name ) const
{
    for( const XMLNode* node = _firstChild; node; node = node->_next ) {
        const XMLElement* element = node->ToElementWithName( name );
        if ( element ) {
            return element;
        }
    }
    return 0;
}
\`\`\`
`,
block49 : `### block 49 : 1057 - 1066

\`\`\`cpp
const XMLElement* XMLNode::LastChildElement( const char* name ) const
{
    for( const XMLNode* node = _lastChild; node; node = node->_prev ) {
        const XMLElement* element = node->ToElementWithName( name );
        if ( element ) {
            return element;
        }
    }
    return 0;
}
\`\`\`
`,
block50 : `### block 50 : 1069 - 1078

\`\`\`cpp
const XMLElement* XMLNode::NextSiblingElement( const char* name ) const
{
    for( const XMLNode* node = _next; node; node = node->_next ) {
        const XMLElement* element = node->ToElementWithName( name );
        if ( element ) {
            return element;
        }
    }
    return 0;
}
\`\`\`
`,
block51 : `### block 51 : 1081 - 1090

\`\`\`cpp
const XMLElement* XMLNode::PreviousSiblingElement( const char* name ) const
{
    for( const XMLNode* node = _prev; node; node = node->_prev ) {
        const XMLElement* element = node->ToElementWithName( name );
        if ( element ) {
            return element;
        }
    }
    return 0;
}
\`\`\`
`,
block52 : `### block 52 : 1093 - 1207

\`\`\`cpp
char* XMLNode::ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr )
{
    // This is a recursive method, but thinking about it "at the current level"
    // it is a pretty simple flat list:
    //		<foo/>
    //		<!-- comment -->
    //
    // With a special case:
    //		<foo>
    //		</foo>
    //		<!-- comment -->
    //
    // Where the closing element (/foo) *must* be the next thing after the opening
    // element, and the names must match. BUT the tricky bit is that the closing
    // element will be read by the child.
    //
    // 'endTag' is the end tag for this node, it is returned by a call to a child.
    // 'parentEnd' is the end tag for the parent, which is filled in and returned.

	XMLDocument::DepthTracker tracker(_document);
	if (_document->Error())
		return 0;

	bool first = true;
	while( p && *p ) {
        XMLNode* node = 0;

        p = _document->Identify( p, &node, first );
        TIXMLASSERT( p );
        if ( node == 0 ) {
            break;
        }
        first = false;

       const int initialLineNum = node->_parseLineNum;

        StrPair endTag;
        p = node->ParseDeep( p, &endTag, curLineNumPtr );
        if ( !p ) {
            _document->DeleteNode( node );
            if ( !_document->Error() ) {
                _document->SetError( XML_ERROR_PARSING, initialLineNum, 0);
            }
            break;
        }

        const XMLDeclaration* const decl = node->ToDeclaration();
        if ( decl ) {
            // Declarations are only allowed at document level
            //
            // Multiple declarations are allowed but all declarations
            // must occur before anything else. 
            //
            // Optimized due to a security test case. If the first node is 
            // a declaration, and the last node is a declaration, then only 
            // declarations have so far been added.
            bool wellLocated = false;

            if (ToDocument()) {
                if (FirstChild()) {
                    wellLocated =
                        FirstChild() &&
                        FirstChild()->ToDeclaration() &&
                        LastChild() &&
                        LastChild()->ToDeclaration();
                }
                else {
                    wellLocated = true;
                }
            }
            if ( !wellLocated ) {
                _document->SetError( XML_ERROR_PARSING_DECLARATION, initialLineNum, "XMLDeclaration value=%s", decl->Value());
                _document->DeleteNode( node );
                break;
            }
        }

        XMLElement* ele = node->ToElement();
        if ( ele ) {
            // We read the end tag. Return it to the parent.
            if ( ele->ClosingType() == XMLElement::CLOSING ) {
                if ( parentEndTag ) {
                    ele->_value.TransferTo( parentEndTag );
                }
                node->_memPool->SetTracked();   // created and then immediately deleted.
                DeleteNode( node );
                return p;
            }

            // Handle an end tag returned to this level.
            // And handle a bunch of annoying errors.
            bool mismatch = false;
            if ( endTag.Empty() ) {
                if ( ele->ClosingType() == XMLElement::OPEN ) {
                    mismatch = true;
                }
            }
            else {
                if ( ele->ClosingType() != XMLElement::OPEN ) {
                    mismatch = true;
                }
                else if ( !XMLUtil::StringEqual( endTag.GetStr(), ele->Name() ) ) {
                    mismatch = true;
                }
            }
            if ( mismatch ) {
                _document->SetError( XML_ERROR_MISMATCHED_ELEMENT, initialLineNum, "XMLElement name=%s", ele->Name());
                _document->DeleteNode( node );
                break;
            }
        }
        InsertEndChild( node );
    }
    return 0;
}
\`\`\`
`,
block53 : `### block 53 : 1209 - 1222

\`\`\`cpp
/*static*/ void XMLNode::DeleteNode( XMLNode* node )
{
    if ( node == 0 ) {
        return;
    }
	TIXMLASSERT(node->_document);
	if (!node->ToDocument()) {
		node->_document->MarkInUse(node);
	}

    MemPool* pool = node->_memPool;
    node->~XMLNode();
    pool->Free( node );
}
\`\`\`
`,
block54 : `### block 54 : 1224 - 1236

\`\`\`cpp
void XMLNode::InsertChildPreamble( XMLNode* insertThis ) const
{
    TIXMLASSERT( insertThis );
    TIXMLASSERT( insertThis->_document == _document );

	if (insertThis->_parent) {
        insertThis->_parent->Unlink( insertThis );
	}
	else {
		insertThis->_document->MarkInUse(insertThis);
        insertThis->_memPool->SetTracked();
	}
}
\`\`\`
`,
block55 : `### block 55 : 1238 - 1251

\`\`\`cpp
const XMLElement* XMLNode::ToElementWithName( const char* name ) const
{
    const XMLElement* element = this->ToElement();
    if ( element == 0 ) {
        return 0;
    }
    if ( name == 0 ) {
        return element;
    }
    if ( XMLUtil::StringEqual( element->Name(), name ) ) {
       return element;
    }
    return 0;
}
\`\`\`
`,
block56 : `### block 56 : 1253 - 1278

\`\`\`cpp
// --------- XMLText ---------- //
char* XMLText::ParseDeep( char* p, StrPair*, int* curLineNumPtr )
{
    if ( this->CData() ) {
        p = _value.ParseText( p, "]]>", StrPair::NEEDS_NEWLINE_NORMALIZATION, curLineNumPtr );
        if ( !p ) {
            _document->SetError( XML_ERROR_PARSING_CDATA, _parseLineNum, 0 );
        }
        return p;
    }
    else {
        int flags = _document->ProcessEntities() ? StrPair::TEXT_ELEMENT : StrPair::TEXT_ELEMENT_LEAVE_ENTITIES;
        if ( _document->WhitespaceMode() == COLLAPSE_WHITESPACE ) {
            flags |= StrPair::NEEDS_WHITESPACE_COLLAPSING;
        }

        p = _value.ParseText( p, "<", flags, curLineNumPtr );
        if ( p && *p ) {
            return p-1;
        }
        if ( !p ) {
            _document->SetError( XML_ERROR_PARSING_TEXT, _parseLineNum, 0 );
        }
    }
    return 0;
}
\`\`\`
`,
block57 : `### block 57 : 1281 - 1289

\`\`\`cpp
XMLNode* XMLText::ShallowClone( XMLDocument* doc ) const
{
    if ( !doc ) {
        doc = _document;
    }
    XMLText* text = doc->NewText( Value() );	// fixme: this will always allocate memory. Intern?
    text->SetCData( this->CData() );
    return text;
}
\`\`\`
`,
block58 : `### block 58 : 1292 - 1297

\`\`\`cpp
bool XMLText::ShallowEqual( const XMLNode* compare ) const
{
    TIXMLASSERT( compare );
    const XMLText* text = compare->ToText();
    return ( text && XMLUtil::StringEqual( text->Value(), Value() ) );
}
\`\`\`
`,
block59 : `### block 59 : 1300 - 1304

\`\`\`cpp
bool XMLText::Accept( XMLVisitor* visitor ) const
{
    TIXMLASSERT( visitor );
    return visitor->Visit( *this );
}
\`\`\`
`,
block60 : `### block 60 : 1307 - 1311

\`\`\`cpp
// --------- XMLComment ---------- //

XMLComment::XMLComment( XMLDocument* doc ) : XMLNode( doc )
{
}
\`\`\`
`,
block61 : `### block 61 : 1314 - 1316

\`\`\`cpp
XMLComment::~XMLComment()
{
}
\`\`\`
`,
block62 : `### block 62 : 1319 - 1327

\`\`\`cpp
char* XMLComment::ParseDeep( char* p, StrPair*, int* curLineNumPtr )
{
    // Comment parses as text.
    p = _value.ParseText( p, "-->", StrPair::COMMENT, curLineNumPtr );
    if ( p == 0 ) {
        _document->SetError( XML_ERROR_PARSING_COMMENT, _parseLineNum, 0 );
    }
    return p;
}
\`\`\`
`,
block63 : `### block 63 : 1330 - 1337

\`\`\`cpp
XMLNode* XMLComment::ShallowClone( XMLDocument* doc ) const
{
    if ( !doc ) {
        doc = _document;
    }
    XMLComment* comment = doc->NewComment( Value() );	// fixme: this will always allocate memory. Intern?
    return comment;
}
\`\`\`
`,
block64 : `### block 64 : 1340 - 1345

\`\`\`cpp
bool XMLComment::ShallowEqual( const XMLNode* compare ) const
{
    TIXMLASSERT( compare );
    const XMLComment* comment = compare->ToComment();
    return ( comment && XMLUtil::StringEqual( comment->Value(), Value() ));
}
\`\`\`
`,
block65 : `### block 65 : 1348 - 1352

\`\`\`cpp
bool XMLComment::Accept( XMLVisitor* visitor ) const
{
    TIXMLASSERT( visitor );
    return visitor->Visit( *this );
}
\`\`\`
`,
block66 : `### block 66 : 1355 - 1359

\`\`\`cpp
// --------- XMLDeclaration ---------- //

XMLDeclaration::XMLDeclaration( XMLDocument* doc ) : XMLNode( doc )
{
}
\`\`\`
`,
block67 : `### block 67 : 1362 - 1365

\`\`\`cpp
XMLDeclaration::~XMLDeclaration()
{
    //printf( "~XMLDeclaration\n" );
}
\`\`\`
`,
block68 : `### block 68 : 1368 - 1376

\`\`\`cpp
char* XMLDeclaration::ParseDeep( char* p, StrPair*, int* curLineNumPtr )
{
    // Declaration parses as text.
    p = _value.ParseText( p, "?>", StrPair::NEEDS_NEWLINE_NORMALIZATION, curLineNumPtr );
    if ( p == 0 ) {
        _document->SetError( XML_ERROR_PARSING_DECLARATION, _parseLineNum, 0 );
    }
    return p;
}
\`\`\`
`,
block69 : `### block 69 : 1379 - 1386

\`\`\`cpp
XMLNode* XMLDeclaration::ShallowClone( XMLDocument* doc ) const
{
    if ( !doc ) {
        doc = _document;
    }
    XMLDeclaration* dec = doc->NewDeclaration( Value() );	// fixme: this will always allocate memory. Intern?
    return dec;
}
\`\`\`
`,
block70 : `### block 70 : 1389 - 1394

\`\`\`cpp
bool XMLDeclaration::ShallowEqual( const XMLNode* compare ) const
{
    TIXMLASSERT( compare );
    const XMLDeclaration* declaration = compare->ToDeclaration();
    return ( declaration && XMLUtil::StringEqual( declaration->Value(), Value() ));
}
\`\`\`
`,
block71 : `### block 71 : 1398 - 1402

\`\`\`cpp
bool XMLDeclaration::Accept( XMLVisitor* visitor ) const
{
    TIXMLASSERT( visitor );
    return visitor->Visit( *this );
}
\`\`\`
`,
block72 : `### block 72 : 1404 - 1408

\`\`\`cpp
// --------- XMLUnknown ---------- //

XMLUnknown::XMLUnknown( XMLDocument* doc ) : XMLNode( doc )
{
}
\`\`\`
`,
block73 : `### block 73 : 1411 - 1413

\`\`\`cpp
XMLUnknown::~XMLUnknown()
{
}
\`\`\`
`,
block74 : `### block 74 : 1416 - 1424

\`\`\`cpp
char* XMLUnknown::ParseDeep( char* p, StrPair*, int* curLineNumPtr )
{
    // Unknown parses as text.
    p = _value.ParseText( p, ">", StrPair::NEEDS_NEWLINE_NORMALIZATION, curLineNumPtr );
    if ( !p ) {
        _document->SetError( XML_ERROR_PARSING_UNKNOWN, _parseLineNum, 0 );
    }
    return p;
}
\`\`\`
`,
block75 : `### block 75 : 1427 - 1434

\`\`\`cpp
XMLNode* XMLUnknown::ShallowClone( XMLDocument* doc ) const
{
    if ( !doc ) {
        doc = _document;
    }
    XMLUnknown* text = doc->NewUnknown( Value() );	// fixme: this will always allocate memory. Intern?
    return text;
}
\`\`\`
`,
block76 : `### block 76 : 1437 - 1442

\`\`\`cpp
bool XMLUnknown::ShallowEqual( const XMLNode* compare ) const
{
    TIXMLASSERT( compare );
    const XMLUnknown* unknown = compare->ToUnknown();
    return ( unknown && XMLUtil::StringEqual( unknown->Value(), Value() ));
}
\`\`\`
`,
block77 : `### block 77 : 1445 - 1449

\`\`\`cpp
bool XMLUnknown::Accept( XMLVisitor* visitor ) const
{
    TIXMLASSERT( visitor );
    return visitor->Visit( *this );
}
\`\`\`
`,
block78 : `### block 78 : 1451 - 1456

\`\`\`cpp
// --------- XMLAttribute ---------- //

const char* XMLAttribute::Name() const
{
    return _name.GetStr();
}
\`\`\`
`,
block79 : `### block 79 : 1458 - 1461

\`\`\`cpp
const char* XMLAttribute::Value() const
{
    return _value.GetStr();
}
\`\`\`
`,
block80 : `### block 80 : 1463 - 1488

\`\`\`cpp
char* XMLAttribute::ParseDeep( char* p, bool processEntities, int* curLineNumPtr )
{
    // Parse using the name rules: bug fix, was using ParseText before
    p = _name.ParseName( p );
    if ( !p || !*p ) {
        return 0;
    }

    // Skip white space before =
    p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );
    if ( *p != '=' ) {
        return 0;
    }

    ++p;	// move up to opening quote
    p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );
    if ( *p != '\"' && *p != '\'' ) {
        return 0;
    }

    const char endTag[2] = { *p, 0 };
    ++p;	// move past opening quote

    p = _value.ParseText( p, endTag, processEntities ? StrPair::ATTRIBUTE_VALUE : StrPair::ATTRIBUTE_VALUE_LEAVE_ENTITIES, curLineNumPtr );
    return p;
}
\`\`\`
`,
block81 : `### block 81 : 1491 - 1494

\`\`\`cpp
void XMLAttribute::SetName( const char* n )
{
    _name.SetStr( n );
}
\`\`\`
`,
block82 : `### block 82 : 1497 - 1503

\`\`\`cpp
XMLError XMLAttribute::QueryIntValue( int* value ) const
{
    if ( XMLUtil::ToInt( Value(), value )) {
        return XML_SUCCESS;
    }
    return XML_WRONG_ATTRIBUTE_TYPE;
}
\`\`\`
`,
block83 : `### block 83 : 1506 - 1512

\`\`\`cpp
XMLError XMLAttribute::QueryUnsignedValue( unsigned int* value ) const
{
    if ( XMLUtil::ToUnsigned( Value(), value )) {
        return XML_SUCCESS;
    }
    return XML_WRONG_ATTRIBUTE_TYPE;
}
\`\`\`
`,
block84 : `### block 84 : 1515 - 1521

\`\`\`cpp
XMLError XMLAttribute::QueryInt64Value(int64_t* value) const
{
	if (XMLUtil::ToInt64(Value(), value)) {
		return XML_SUCCESS;
	}
	return XML_WRONG_ATTRIBUTE_TYPE;
}
\`\`\`
`,
block85 : `### block 85 : 1524 - 1530

\`\`\`cpp
XMLError XMLAttribute::QueryUnsigned64Value(uint64_t* value) const
{
    if(XMLUtil::ToUnsigned64(Value(), value)) {
        return XML_SUCCESS;
    }
    return XML_WRONG_ATTRIBUTE_TYPE;
}
\`\`\`
`,
block86 : `### block 86 : 1533 - 1539

\`\`\`cpp
XMLError XMLAttribute::QueryBoolValue( bool* value ) const
{
    if ( XMLUtil::ToBool( Value(), value )) {
        return XML_SUCCESS;
    }
    return XML_WRONG_ATTRIBUTE_TYPE;
}
\`\`\`
`,
block87 : `### block 87 : 1542 - 1548

\`\`\`cpp
XMLError XMLAttribute::QueryFloatValue( float* value ) const
{
    if ( XMLUtil::ToFloat( Value(), value )) {
        return XML_SUCCESS;
    }
    return XML_WRONG_ATTRIBUTE_TYPE;
}
\`\`\`
`,
block88 : `### block 88 : 1551 - 1557

\`\`\`cpp
XMLError XMLAttribute::QueryDoubleValue( double* value ) const
{
    if ( XMLUtil::ToDouble( Value(), value )) {
        return XML_SUCCESS;
    }
    return XML_WRONG_ATTRIBUTE_TYPE;
}
\`\`\`
`,
block89 : `### block 89 : 1560 - 1563

\`\`\`cpp
void XMLAttribute::SetAttribute( const char* v )
{
    _value.SetStr( v );
}
\`\`\`
`,
block90 : `### block 90 : 1566 - 1571

\`\`\`cpp
void XMLAttribute::SetAttribute( int v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    _value.SetStr( buf );
}
\`\`\`
`,
block91 : `### block 91 : 1574 - 1579

\`\`\`cpp
void XMLAttribute::SetAttribute( unsigned v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    _value.SetStr( buf );
}
\`\`\`
`,
block92 : `### block 92 : 1582 - 1587

\`\`\`cpp
void XMLAttribute::SetAttribute(int64_t v)
{
	char buf[BUF_SIZE];
	XMLUtil::ToStr(v, buf, BUF_SIZE);
	_value.SetStr(buf);
}
\`\`\`
`,
block93 : `### block 93 : 1589 - 1594

\`\`\`cpp
void XMLAttribute::SetAttribute(uint64_t v)
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr(v, buf, BUF_SIZE);
    _value.SetStr(buf);
}
\`\`\`
`,
block94 : `### block 94 : 1597 - 1602

\`\`\`cpp
void XMLAttribute::SetAttribute( bool v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    _value.SetStr( buf );
}
\`\`\`
`,
block95 : `### block 95 : 1604 - 1609

\`\`\`cpp
void XMLAttribute::SetAttribute( double v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    _value.SetStr( buf );
}
\`\`\`
`,
block96 : `### block 96 : 1611 - 1616

\`\`\`cpp
void XMLAttribute::SetAttribute( float v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    _value.SetStr( buf );
}
\`\`\`
`,
block97 : `### block 97 : 1619 - 1624

\`\`\`cpp
// --------- XMLElement ---------- //
XMLElement::XMLElement( XMLDocument* doc ) : XMLNode( doc ),
    _closingType( OPEN ),
    _rootAttribute( 0 )
{
}
\`\`\`
`,
block98 : `### block 98 : 1627 - 1634

\`\`\`cpp
XMLElement::~XMLElement()
{
    while( _rootAttribute ) {
        XMLAttribute* next = _rootAttribute->_next;
        DeleteAttribute( _rootAttribute );
        _rootAttribute = next;
    }
}
\`\`\`
`,
block99 : `### block 99 : 1637 - 1645

\`\`\`cpp
const XMLAttribute* XMLElement::FindAttribute( const char* name ) const
{
    for( XMLAttribute* a = _rootAttribute; a; a = a->_next ) {
        if ( XMLUtil::StringEqual( a->Name(), name ) ) {
            return a;
        }
    }
    return 0;
}
\`\`\`
`,
block100 : `### block 100 : 1648 - 1658

\`\`\`cpp
const char* XMLElement::Attribute( const char* name, const char* value ) const
{
    const XMLAttribute* a = FindAttribute( name );
    if ( !a ) {
        return 0;
    }
    if ( !value || XMLUtil::StringEqual( a->Value(), value )) {
        return a->Value();
    }
    return 0;
}
\`\`\`
`,
block101 : `### block 101 : 1660 - 1665

\`\`\`cpp
int XMLElement::IntAttribute(const char* name, int defaultValue) const
{
	int i = defaultValue;
	QueryIntAttribute(name, &i);
	return i;
}
\`\`\`
`,
block102 : `### block 102 : 1667 - 1672

\`\`\`cpp
unsigned XMLElement::UnsignedAttribute(const char* name, unsigned defaultValue) const
{
	unsigned i = defaultValue;
	QueryUnsignedAttribute(name, &i);
	return i;
}
\`\`\`
`,
block103 : `### block 103 : 1674 - 1679

\`\`\`cpp
int64_t XMLElement::Int64Attribute(const char* name, int64_t defaultValue) const
{
	int64_t i = defaultValue;
	QueryInt64Attribute(name, &i);
	return i;
}
\`\`\`
`,
block104 : `### block 104 : 1681 - 1686

\`\`\`cpp
uint64_t XMLElement::Unsigned64Attribute(const char* name, uint64_t defaultValue) const
{
	uint64_t i = defaultValue;
	QueryUnsigned64Attribute(name, &i);
	return i;
}
\`\`\`
`,
block105 : `### block 105 : 1688 - 1693

\`\`\`cpp
bool XMLElement::BoolAttribute(const char* name, bool defaultValue) const
{
	bool b = defaultValue;
	QueryBoolAttribute(name, &b);
	return b;
}
\`\`\`
`,
block106 : `### block 106 : 1695 - 1700

\`\`\`cpp
double XMLElement::DoubleAttribute(const char* name, double defaultValue) const
{
	double d = defaultValue;
	QueryDoubleAttribute(name, &d);
	return d;
}
\`\`\`
`,
block107 : `### block 107 : 1702 - 1707

\`\`\`cpp
float XMLElement::FloatAttribute(const char* name, float defaultValue) const
{
	float f = defaultValue;
	QueryFloatAttribute(name, &f);
	return f;
}
\`\`\`
`,
block108 : `### block 108 : 1709 - 1725

\`\`\`cpp
const char* XMLElement::GetText() const
{
    /* skip comment node */
    const XMLNode* node = FirstChild();
    while (node) {
        if (node->ToComment()) {
            node = node->NextSibling();
            continue;
        }
        break;
    }

    if ( node && node->ToText() ) {
        return node->Value();
    }
    return 0;
}
\`\`\`
`,
block109 : `### block 109 : 1728 - 1736

\`\`\`cpp
void	XMLElement::SetText( const char* inText )
{
	if ( FirstChild() && FirstChild()->ToText() )
		FirstChild()->SetValue( inText );
	else {
		XMLText*	theText = GetDocument()->NewText( inText );
		InsertFirstChild( theText );
	}
}
\`\`\`
`,
block110 : `### block 110 : 1739 - 1744

\`\`\`cpp
void XMLElement::SetText( int v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    SetText( buf );
}
\`\`\`
`,
block111 : `### block 111 : 1747 - 1752

\`\`\`cpp
void XMLElement::SetText( unsigned v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    SetText( buf );
}
\`\`\`
`,
block112 : `### block 112 : 1755 - 1760

\`\`\`cpp
void XMLElement::SetText(int64_t v)
{
	char buf[BUF_SIZE];
	XMLUtil::ToStr(v, buf, BUF_SIZE);
	SetText(buf);
}
\`\`\`
`,
block113 : `### block 113 : 1762 - 1766

\`\`\`cpp
void XMLElement::SetText(uint64_t v) {
    char buf[BUF_SIZE];
    XMLUtil::ToStr(v, buf, BUF_SIZE);
    SetText(buf);
}
\`\`\`
`,
block114 : `### block 114 : 1769 - 1774

\`\`\`cpp
void XMLElement::SetText( bool v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    SetText( buf );
}
\`\`\`
`,
block115 : `### block 115 : 1777 - 1782

\`\`\`cpp
void XMLElement::SetText( float v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    SetText( buf );
}
\`\`\`
`,
block116 : `### block 116 : 1785 - 1790

\`\`\`cpp
void XMLElement::SetText( double v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    SetText( buf );
}
\`\`\`
`,
block117 : `### block 117 : 1793 - 1803

\`\`\`cpp
XMLError XMLElement::QueryIntText( int* ival ) const
{
    if ( FirstChild() && FirstChild()->ToText() ) {
        const char* t = FirstChild()->Value();
        if ( XMLUtil::ToInt( t, ival ) ) {
            return XML_SUCCESS;
        }
        return XML_CAN_NOT_CONVERT_TEXT;
    }
    return XML_NO_TEXT_NODE;
}
\`\`\`
`,
block118 : `### block 118 : 1806 - 1816

\`\`\`cpp
XMLError XMLElement::QueryUnsignedText( unsigned* uval ) const
{
    if ( FirstChild() && FirstChild()->ToText() ) {
        const char* t = FirstChild()->Value();
        if ( XMLUtil::ToUnsigned( t, uval ) ) {
            return XML_SUCCESS;
        }
        return XML_CAN_NOT_CONVERT_TEXT;
    }
    return XML_NO_TEXT_NODE;
}
\`\`\`
`,
block119 : `### block 119 : 1819 - 1829

\`\`\`cpp
XMLError XMLElement::QueryInt64Text(int64_t* ival) const
{
	if (FirstChild() && FirstChild()->ToText()) {
		const char* t = FirstChild()->Value();
		if (XMLUtil::ToInt64(t, ival)) {
			return XML_SUCCESS;
		}
		return XML_CAN_NOT_CONVERT_TEXT;
	}
	return XML_NO_TEXT_NODE;
}
\`\`\`
`,
block120 : `### block 120 : 1832 - 1842

\`\`\`cpp
XMLError XMLElement::QueryUnsigned64Text(uint64_t* uval) const
{
    if(FirstChild() && FirstChild()->ToText()) {
        const char* t = FirstChild()->Value();
        if(XMLUtil::ToUnsigned64(t, uval)) {
            return XML_SUCCESS;
        }
        return XML_CAN_NOT_CONVERT_TEXT;
    }
    return XML_NO_TEXT_NODE;
}
\`\`\`
`,
block121 : `### block 121 : 1845 - 1855

\`\`\`cpp
XMLError XMLElement::QueryBoolText( bool* bval ) const
{
    if ( FirstChild() && FirstChild()->ToText() ) {
        const char* t = FirstChild()->Value();
        if ( XMLUtil::ToBool( t, bval ) ) {
            return XML_SUCCESS;
        }
        return XML_CAN_NOT_CONVERT_TEXT;
    }
    return XML_NO_TEXT_NODE;
}
\`\`\`
`,
block122 : `### block 122 : 1858 - 1868

\`\`\`cpp
XMLError XMLElement::QueryDoubleText( double* dval ) const
{
    if ( FirstChild() && FirstChild()->ToText() ) {
        const char* t = FirstChild()->Value();
        if ( XMLUtil::ToDouble( t, dval ) ) {
            return XML_SUCCESS;
        }
        return XML_CAN_NOT_CONVERT_TEXT;
    }
    return XML_NO_TEXT_NODE;
}
\`\`\`
`,
block123 : `### block 123 : 1871 - 1881

\`\`\`cpp
XMLError XMLElement::QueryFloatText( float* fval ) const
{
    if ( FirstChild() && FirstChild()->ToText() ) {
        const char* t = FirstChild()->Value();
        if ( XMLUtil::ToFloat( t, fval ) ) {
            return XML_SUCCESS;
        }
        return XML_CAN_NOT_CONVERT_TEXT;
    }
    return XML_NO_TEXT_NODE;
}
\`\`\`
`,
block124 : `### block 124 : 1883 - 1888

\`\`\`cpp
int XMLElement::IntText(int defaultValue) const
{
	int i = defaultValue;
	QueryIntText(&i);
	return i;
}
\`\`\`
`,
block125 : `### block 125 : 1890 - 1895

\`\`\`cpp
unsigned XMLElement::UnsignedText(unsigned defaultValue) const
{
	unsigned i = defaultValue;
	QueryUnsignedText(&i);
	return i;
}
\`\`\`
`,
block126 : `### block 126 : 1897 - 1902

\`\`\`cpp
int64_t XMLElement::Int64Text(int64_t defaultValue) const
{
	int64_t i = defaultValue;
	QueryInt64Text(&i);
	return i;
}
\`\`\`
`,
block127 : `### block 127 : 1904 - 1909

\`\`\`cpp
uint64_t XMLElement::Unsigned64Text(uint64_t defaultValue) const
{
	uint64_t i = defaultValue;
	QueryUnsigned64Text(&i);
	return i;
}
\`\`\`
`,
block128 : `### block 128 : 1911 - 1916

\`\`\`cpp
bool XMLElement::BoolText(bool defaultValue) const
{
	bool b = defaultValue;
	QueryBoolText(&b);
	return b;
}
\`\`\`
`,
block129 : `### block 129 : 1918 - 1923

\`\`\`cpp
double XMLElement::DoubleText(double defaultValue) const
{
	double d = defaultValue;
	QueryDoubleText(&d);
	return d;
}
\`\`\`
`,
block130 : `### block 130 : 1925 - 1930

\`\`\`cpp
float XMLElement::FloatText(float defaultValue) const
{
	float f = defaultValue;
	QueryFloatText(&f);
	return f;
}
\`\`\`
`,
block131 : `### block 131 : 1933 - 1958

\`\`\`cpp
XMLAttribute* XMLElement::FindOrCreateAttribute( const char* name )
{
    XMLAttribute* last = 0;
    XMLAttribute* attrib = 0;
    for( attrib = _rootAttribute;
            attrib;
            last = attrib, attrib = attrib->_next ) {
        if ( XMLUtil::StringEqual( attrib->Name(), name ) ) {
            break;
        }
    }
    if ( !attrib ) {
        attrib = CreateAttribute();
        TIXMLASSERT( attrib );
        if ( last ) {
            TIXMLASSERT( last->_next == 0 );
            last->_next = attrib;
        }
        else {
            TIXMLASSERT( _rootAttribute == 0 );
            _rootAttribute = attrib;
        }
        attrib->SetName( name );
    }
    return attrib;
}
\`\`\`
`,
block132 : `### block 132 : 1961 - 1977

\`\`\`cpp
void XMLElement::DeleteAttribute( const char* name )
{
    XMLAttribute* prev = 0;
    for( XMLAttribute* a=_rootAttribute; a; a=a->_next ) {
        if ( XMLUtil::StringEqual( name, a->Name() ) ) {
            if ( prev ) {
                prev->_next = a->_next;
            }
            else {
                _rootAttribute = a->_next;
            }
            DeleteAttribute( a );
            break;
        }
        prev = a;
    }
}
\`\`\`
`,
block133 : `### block 133 : 1980 - 2037

\`\`\`cpp
char* XMLElement::ParseAttributes( char* p, int* curLineNumPtr )
{
    XMLAttribute* prevAttribute = 0;

    // Read the attributes.
    while( p ) {
        p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );
        if ( !(*p) ) {
            _document->SetError( XML_ERROR_PARSING_ELEMENT, _parseLineNum, "XMLElement name=%s", Name() );
            return 0;
        }

        // attribute.
        if (XMLUtil::IsNameStartChar( static_cast<unsigned char>(*p) ) ) {
            XMLAttribute* attrib = CreateAttribute();
            TIXMLASSERT( attrib );
            attrib->_parseLineNum = _document->_parseCurLineNum;

            const int attrLineNum = attrib->_parseLineNum;

            p = attrib->ParseDeep( p, _document->ProcessEntities(), curLineNumPtr );
            if ( !p || Attribute( attrib->Name() ) ) {
                DeleteAttribute( attrib );
                _document->SetError( XML_ERROR_PARSING_ATTRIBUTE, attrLineNum, "XMLElement name=%s", Name() );
                return 0;
            }
            // There is a minor bug here: if the attribute in the source xml
            // document is duplicated, it will not be detected and the
            // attribute will be doubly added. However, tracking the 'prevAttribute'
            // avoids re-scanning the attribute list. Preferring performance for
            // now, may reconsider in the future.
            if ( prevAttribute ) {
                TIXMLASSERT( prevAttribute->_next == 0 );
                prevAttribute->_next = attrib;
            }
            else {
                TIXMLASSERT( _rootAttribute == 0 );
                _rootAttribute = attrib;
            }
            prevAttribute = attrib;
        }
        // end of the tag
        else if ( *p == '>' ) {
            ++p;
            break;
        }
        // end of the tag
        else if ( *p == '/' && *(p+1) == '>' ) {
            _closingType = CLOSED;
            return p+2;	// done; sealed element.
        }
        else {
            _document->SetError( XML_ERROR_PARSING_ELEMENT, _parseLineNum, 0 );
            return 0;
        }
    }
    return p;
}
\`\`\`
`,
block134 : `### block 134 : 2039 - 2047

\`\`\`cpp
void XMLElement::DeleteAttribute( XMLAttribute* attribute )
{
    if ( attribute == 0 ) {
        return;
    }
    MemPool* pool = attribute->_memPool;
    attribute->~XMLAttribute();
    pool->Free( attribute );
}
\`\`\`
`,
block135 : `### block 135 : 2049 - 2057

\`\`\`cpp
XMLAttribute* XMLElement::CreateAttribute()
{
    TIXMLASSERT( sizeof( XMLAttribute ) == _document->_attributePool.ItemSize() );
    XMLAttribute* attrib = new (_document->_attributePool.Alloc() ) XMLAttribute();
    TIXMLASSERT( attrib );
    attrib->_memPool = &_document->_attributePool;
    attrib->_memPool->SetTracked();
    return attrib;
}
\`\`\`
`,
block136 : `### block 136 : 2060 - 2064

\`\`\`cpp
XMLElement* XMLElement::InsertNewChildElement(const char* name)
{
    XMLElement* node = _document->NewElement(name);
    return InsertEndChild(node) ? node : 0;
}
\`\`\`
`,
block137 : `### block 137 : 2066 - 2070

\`\`\`cpp
XMLComment* XMLElement::InsertNewComment(const char* comment)
{
    XMLComment* node = _document->NewComment(comment);
    return InsertEndChild(node) ? node : 0;
}
\`\`\`
`,
block138 : `### block 138 : 2072 - 2076

\`\`\`cpp
XMLText* XMLElement::InsertNewText(const char* text)
{
    XMLText* node = _document->NewText(text);
    return InsertEndChild(node) ? node : 0;
}
\`\`\`
`,
block139 : `### block 139 : 2078 - 2082

\`\`\`cpp
XMLDeclaration* XMLElement::InsertNewDeclaration(const char* text)
{
    XMLDeclaration* node = _document->NewDeclaration(text);
    return InsertEndChild(node) ? node : 0;
}
\`\`\`
`,
block140 : `### block 140 : 2084 - 2088

\`\`\`cpp
XMLUnknown* XMLElement::InsertNewUnknown(const char* text)
{
    XMLUnknown* node = _document->NewUnknown(text);
    return InsertEndChild(node) ? node : 0;
}
\`\`\`
`,
block141 : `### block 141 : 2092 - 2121

\`\`\`cpp
//
//	<ele></ele>
//	<ele>foo<b>bar</b></ele>
//
char* XMLElement::ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr )
{
    // Read the element name.
    p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );

    // The closing element is the </element> form. It is
    // parsed just like a regular element then deleted from
    // the DOM.
    if ( *p == '/' ) {
        _closingType = CLOSING;
        ++p;
    }

    p = _value.ParseName( p );
    if ( _value.Empty() ) {
        return 0;
    }

    p = ParseAttributes( p, curLineNumPtr );
    if ( !p || !*p || _closingType != OPEN ) {
        return p;
    }

    p = XMLNode::ParseDeep( p, parentEndTag, curLineNumPtr );
    return p;
}
\`\`\`
`,
block142 : `### block 142 : 2125 - 2135

\`\`\`cpp
XMLNode* XMLElement::ShallowClone( XMLDocument* doc ) const
{
    if ( !doc ) {
        doc = _document;
    }
    XMLElement* element = doc->NewElement( Value() );					// fixme: this will always allocate memory. Intern?
    for( const XMLAttribute* a=FirstAttribute(); a; a=a->Next() ) {
        element->SetAttribute( a->Name(), a->Value() );					// fixme: this will always allocate memory. Intern?
    }
    return element;
}
\`\`\`
`,
block143 : `### block 143 : 2138 - 2161

\`\`\`cpp
bool XMLElement::ShallowEqual( const XMLNode* compare ) const
{
    TIXMLASSERT( compare );
    const XMLElement* other = compare->ToElement();
    if ( other && XMLUtil::StringEqual( other->Name(), Name() )) {

        const XMLAttribute* a=FirstAttribute();
        const XMLAttribute* b=other->FirstAttribute();

        while ( a && b ) {
            if ( !XMLUtil::StringEqual( a->Value(), b->Value() ) ) {
                return false;
            }
            a = a->Next();
            b = b->Next();
        }
        if ( a || b ) {
            // different count
            return false;
        }
        return true;
    }
    return false;
}
\`\`\`
`,
block144 : `### block 144 : 2164 - 2175

\`\`\`cpp
bool XMLElement::Accept( XMLVisitor* visitor ) const
{
    TIXMLASSERT( visitor );
    if ( visitor->VisitEnter( *this, _rootAttribute ) ) {
        for ( const XMLNode* node=FirstChild(); node; node=node->NextSibling() ) {
            if ( !node->Accept( visitor ) ) {
                break;
            }
        }
    }
    return visitor->VisitExit( *this );
}
\`\`\`
`,
block145 : `### block 145 : 2178 - 2201

\`\`\`cpp
// --------- XMLDocument ----------- //

// Warning: List must match 'enum XMLError'
const char* XMLDocument::_errorNames[XML_ERROR_COUNT] = {
    "XML_SUCCESS",
    "XML_NO_ATTRIBUTE",
    "XML_WRONG_ATTRIBUTE_TYPE",
    "XML_ERROR_FILE_NOT_FOUND",
    "XML_ERROR_FILE_COULD_NOT_BE_OPENED",
    "XML_ERROR_FILE_READ_ERROR",
    "XML_ERROR_PARSING_ELEMENT",
    "XML_ERROR_PARSING_ATTRIBUTE",
    "XML_ERROR_PARSING_TEXT",
    "XML_ERROR_PARSING_CDATA",
    "XML_ERROR_PARSING_COMMENT",
    "XML_ERROR_PARSING_DECLARATION",
    "XML_ERROR_PARSING_UNKNOWN",
    "XML_ERROR_EMPTY_DOCUMENT",
    "XML_ERROR_MISMATCHED_ELEMENT",
    "XML_ERROR_PARSING",
    "XML_CAN_NOT_CONVERT_TEXT",
    "XML_NO_TEXT_NODE",
	"XML_ELEMENT_DEPTH_EXCEEDED"
};
\`\`\`
`,
block146 : `### block 146 : 2204 - 2223

\`\`\`cpp
XMLDocument::XMLDocument( bool processEntities, Whitespace whitespaceMode ) :
    XMLNode( 0 ),
    _writeBOM( false ),
    _processEntities( processEntities ),
    _errorID(XML_SUCCESS),
    _whitespaceMode( whitespaceMode ),
    _errorStr(),
    _errorLineNum( 0 ),
    _charBuffer( 0 ),
    _parseCurLineNum( 0 ),
	_parsingDepth(0),
    _unlinked(),
    _elementPool(),
    _attributePool(),
    _textPool(),
    _commentPool()
{
    // avoid VC++ C4355 warning about 'this' in initializer list (C4355 is off by default in VS2012+)
    _document = this;
}
\`\`\`
`,
block147 : `### block 147 : 2226 - 2229

\`\`\`cpp
XMLDocument::~XMLDocument()
{
    Clear();
}
\`\`\`
`,
block148 : `### block 148 : 2232 - 2243

\`\`\`cpp
void XMLDocument::MarkInUse(const XMLNode* const node)
{
	TIXMLASSERT(node);
	TIXMLASSERT(node->_parent == 0);

	for (size_t i = 0; i < _unlinked.Size(); ++i) {
		if (node == _unlinked[i]) {
			_unlinked.SwapRemove(i);
			break;
		}
	}
}
\`\`\`
`,
block149 : `### block 149 : 2245 - 2276

\`\`\`cpp
void XMLDocument::Clear()
{
    DeleteChildren();
	while( _unlinked.Size()) {
		DeleteNode(_unlinked[0]);	// Will remove from _unlinked as part of delete.
	}

#ifdef TINYXML2_DEBUG
    const bool hadError = Error();
#endif
    ClearError();

    delete [] _charBuffer;
    _charBuffer = 0;
	_parsingDepth = 0;

#if 0
    _textPool.Trace( "text" );
    _elementPool.Trace( "element" );
    _commentPool.Trace( "comment" );
    _attributePool.Trace( "attribute" );
#endif

#ifdef TINYXML2_DEBUG
    if ( !hadError ) {
        TIXMLASSERT( _elementPool.CurrentAllocs()   == _elementPool.Untracked() );
        TIXMLASSERT( _attributePool.CurrentAllocs() == _attributePool.Untracked() );
        TIXMLASSERT( _textPool.CurrentAllocs()      == _textPool.Untracked() );
        TIXMLASSERT( _commentPool.CurrentAllocs()   == _commentPool.Untracked() );
    }
#endif
}
\`\`\`
`,
block150 : `### block 150 : 2279 - 2290

\`\`\`cpp
void XMLDocument::DeepCopy(XMLDocument* target) const
{
	TIXMLASSERT(target);
    if (target == this) {
        return; // technically success - a no-op.
    }

	target->Clear();
	for (const XMLNode* node = this->FirstChild(); node; node = node->NextSibling()) {
		target->InsertEndChild(node->DeepClone(target));
	}
}
\`\`\`
`,
block151 : `### block 151 : 2292 - 2297

\`\`\`cpp
XMLElement* XMLDocument::NewElement( const char* name )
{
    XMLElement* ele = CreateUnlinkedNode<XMLElement>( _elementPool );
    ele->SetName( name );
    return ele;
}
\`\`\`
`,
block152 : `### block 152 : 2300 - 2305

\`\`\`cpp
XMLComment* XMLDocument::NewComment( const char* str )
{
    XMLComment* comment = CreateUnlinkedNode<XMLComment>( _commentPool );
    comment->SetValue( str );
    return comment;
}
\`\`\`
`,
block153 : `### block 153 : 2308 - 2313

\`\`\`cpp
XMLText* XMLDocument::NewText( const char* str )
{
    XMLText* text = CreateUnlinkedNode<XMLText>( _textPool );
    text->SetValue( str );
    return text;
}
\`\`\`
`,
block154 : `### block 154 : 2316 - 2321

\`\`\`cpp
XMLDeclaration* XMLDocument::NewDeclaration( const char* str )
{
    XMLDeclaration* dec = CreateUnlinkedNode<XMLDeclaration>( _commentPool );
    dec->SetValue( str ? str : "xml version=\"1.0\" encoding=\"UTF-8\"" );
    return dec;
}
\`\`\`
`,
block155 : `### block 155 : 2324 - 2329

\`\`\`cpp
XMLUnknown* XMLDocument::NewUnknown( const char* str )
{
    XMLUnknown* unk = CreateUnlinkedNode<XMLUnknown>( _commentPool );
    unk->SetValue( str );
    return unk;
}
\`\`\`
`,
block156 : `### block 156 : 2331 - 2345

\`\`\`cpp
static FILE* callfopen( const char* filepath, const char* mode )
{
    TIXMLASSERT( filepath );
    TIXMLASSERT( mode );
#if defined(_MSC_VER) && (_MSC_VER >= 1400 ) && (!defined WINCE)
    FILE* fp = 0;
    const errno_t err = fopen_s( &fp, filepath, mode );
    if ( err ) {
        return 0;
    }
#else
    FILE* fp = fopen( filepath, mode );
#endif
    return fp;
}
\`\`\`
`,
block157 : `### block 157 : 2347 - 2362

\`\`\`cpp
void XMLDocument::DeleteNode( XMLNode* node )	{
    TIXMLASSERT( node );
    TIXMLASSERT(node->_document == this );
    if (node->_parent) {
        node->_parent->DeleteChild( node );
    }
    else {
        // Isn't in the tree.
        // Use the parent delete.
        // Also, we need to mark it tracked: we 'know'
        // it was never used.
        node->_memPool->SetTracked();
        // Call the static XMLNode version:
        XMLNode::DeleteNode(node);
    }
}
\`\`\`
`,
block158 : `### block 158 : 2365 - 2382

\`\`\`cpp
XMLError XMLDocument::LoadFile( const char* filename )
{
    if ( !filename ) {
        TIXMLASSERT( false );
        SetError( XML_ERROR_FILE_COULD_NOT_BE_OPENED, 0, "filename=<null>" );
        return _errorID;
    }

    Clear();
    FILE* fp = callfopen( filename, "rb" );
    if ( !fp ) {
        SetError( XML_ERROR_FILE_NOT_FOUND, 0, "filename=%s", filename );
        return _errorID;
    }
    LoadFile( fp );
    fclose( fp );
    return _errorID;
}
\`\`\`
`,
block159 : `### block 159 : 2384 - 2435

\`\`\`cpp
XMLError XMLDocument::LoadFile( FILE* fp )
{
    Clear();

    TIXML_FSEEK( fp, 0, SEEK_SET );
    if ( fgetc( fp ) == EOF && ferror( fp ) != 0 ) {
        SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );
        return _errorID;
    }

    TIXML_FSEEK( fp, 0, SEEK_END );

    unsigned long long filelength;
    {
        const long long fileLengthSigned = TIXML_FTELL( fp );
        TIXML_FSEEK( fp, 0, SEEK_SET );
        if ( fileLengthSigned == -1L ) {
            SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );
            return _errorID;
        }
        TIXMLASSERT( fileLengthSigned >= 0 );
        filelength = static_cast<unsigned long long>(fileLengthSigned);
    }

    const size_t maxSizeT = static_cast<size_t>(-1);
    // We'll do the comparison as an unsigned long long, because that's guaranteed to be at
    // least 8 bytes, even on a 32-bit platform.
    if ( filelength >= static_cast<unsigned long long>(maxSizeT) ) {
        // Cannot handle files which won't fit in buffer together with null terminator
        SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );
        return _errorID;
    }

    if ( filelength == 0 ) {
        SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );
        return _errorID;
    }

    const size_t size = static_cast<size_t>(filelength);
    TIXMLASSERT( _charBuffer == 0 );
    _charBuffer = new char[size+1];
    const size_t read = fread( _charBuffer, 1, size, fp );
    if ( read != size ) {
        SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );
        return _errorID;
    }

    _charBuffer[size] = 0;

    Parse();
    return _errorID;
}
\`\`\`
`,
block160 : `### block 160 : 2438 - 2454

\`\`\`cpp
XMLError XMLDocument::SaveFile( const char* filename, bool compact )
{
    if ( !filename ) {
        TIXMLASSERT( false );
        SetError( XML_ERROR_FILE_COULD_NOT_BE_OPENED, 0, "filename=<null>" );
        return _errorID;
    }

    FILE* fp = callfopen( filename, "w" );
    if ( !fp ) {
        SetError( XML_ERROR_FILE_COULD_NOT_BE_OPENED, 0, "filename=%s", filename );
        return _errorID;
    }
    SaveFile(fp, compact);
    fclose( fp );
    return _errorID;
}
\`\`\`
`,
block161 : `### block 161 : 2457 - 2465

\`\`\`cpp
XMLError XMLDocument::SaveFile( FILE* fp, bool compact )
{
    // Clear any error from the last save, otherwise it will get reported
    // for *this* call.
    ClearError();
    XMLPrinter stream( fp, compact );
    Print( &stream );
    return _errorID;
}
\`\`\`
`,
block162 : `### block 162 : 2468 - 2496

\`\`\`cpp
XMLError XMLDocument::Parse( const char* xml, size_t nBytes )
{
    Clear();

    if ( nBytes == 0 || !xml || !*xml ) {
        SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );
        return _errorID;
    }
    if ( nBytes == static_cast<size_t>(-1) ) {
        nBytes = strlen( xml );
    }
    TIXMLASSERT( _charBuffer == 0 );
    _charBuffer = new char[ nBytes+1 ];
    memcpy( _charBuffer, xml, nBytes );
    _charBuffer[nBytes] = 0;

    Parse();
    if ( Error() ) {
        // clean up now essentially dangling memory.
        // and the parse fail can put objects in the
        // pools that are dead and inaccessible.
        DeleteChildren();
        _elementPool.Clear();
        _attributePool.Clear();
        _textPool.Clear();
        _commentPool.Clear();
    }
    return _errorID;
}
\`\`\`
`,
block163 : `### block 163 : 2499 - 2508

\`\`\`cpp
void XMLDocument::Print( XMLPrinter* streamer ) const
{
    if ( streamer ) {
        Accept( streamer );
    }
    else {
        XMLPrinter stdoutStreamer( stdout );
        Accept( &stdoutStreamer );
    }
}
\`\`\`
`,
block164 : `### block 164 : 2511 - 2515

\`\`\`cpp
void XMLDocument::ClearError() {
    _errorID = XML_SUCCESS;
    _errorLineNum = 0;
    _errorStr.Reset();
}
\`\`\`
`,
block165 : `### block 165 : 2518 - 2544

\`\`\`cpp
void XMLDocument::SetError( XMLError error, int lineNum, const char* format, ... )
{
    TIXMLASSERT(error >= 0 && error < XML_ERROR_COUNT);
    _errorID = error;
    _errorLineNum = lineNum;
	_errorStr.Reset();

    const size_t BUFFER_SIZE = 1000;
    char* buffer = new char[BUFFER_SIZE];

    TIXMLASSERT(sizeof(error) <= sizeof(int));
    TIXML_SNPRINTF(buffer, BUFFER_SIZE, "Error=%s ErrorID=%d (0x%x) Line number=%d",
        ErrorIDToName(error), static_cast<int>(error), static_cast<unsigned int>(error), lineNum);

	if (format) {
		size_t len = strlen(buffer);
		TIXML_SNPRINTF(buffer + len, BUFFER_SIZE - len, ": ");
		len = strlen(buffer);

		va_list va;
		va_start(va, format);
		TIXML_VSNPRINTF(buffer + len, BUFFER_SIZE - len, format, va);
		va_end(va);
	}
	_errorStr.SetStr(buffer);
	delete[] buffer;
}
\`\`\`
`,
block166 : `### block 166 : 2547 - 2553

\`\`\`cpp
/*static*/ const char* XMLDocument::ErrorIDToName(XMLError errorID)
{
	TIXMLASSERT( errorID >= 0 && errorID < XML_ERROR_COUNT );
    const char* errorName = _errorNames[errorID];
    TIXMLASSERT( errorName && errorName[0] );
    return errorName;
}
\`\`\`
`,
block167 : `### block 167 : 2555 - 2558

\`\`\`cpp
const char* XMLDocument::ErrorStr() const
{
	return _errorStr.Empty() ? "" : _errorStr.GetStr();
}
\`\`\`
`,
block168 : `### block 168 : 2561 - 2564

\`\`\`cpp
void XMLDocument::PrintError() const
{
    printf("%s\n", ErrorStr());
}
\`\`\`
`,
block169 : `### block 169 : 2566 - 2569

\`\`\`cpp
const char* XMLDocument::ErrorName() const
{
    return ErrorIDToName(_errorID);
}
\`\`\`
`,
block170 : `### block 170 : 2571 - 2585

\`\`\`cpp
void XMLDocument::Parse()
{
    TIXMLASSERT( NoChildren() ); // Clear() must have been called previously
    TIXMLASSERT( _charBuffer );
    _parseCurLineNum = 1;
    _parseLineNum = 1;
    char* p = _charBuffer;
    p = XMLUtil::SkipWhiteSpace( p, &_parseCurLineNum );
    p = const_cast<char*>( XMLUtil::ReadBOM( p, &_writeBOM ) );
    if ( !*p ) {
        SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );
        return;
    }
    ParseDeep(p, 0, &_parseCurLineNum );
}
\`\`\`
`,
block171 : `### block 171 : 2587 - 2593

\`\`\`cpp
void XMLDocument::PushDepth()
{
	_parsingDepth++;
	if (_parsingDepth == TINYXML2_MAX_ELEMENT_DEPTH) {
		SetError(XML_ELEMENT_DEPTH_EXCEEDED, _parseCurLineNum, "Element nesting is too deep." );
	}
}
\`\`\`
`,
block172 : `### block 172 : 2595 - 2599

\`\`\`cpp
void XMLDocument::PopDepth()
{
	TIXMLASSERT(_parsingDepth > 0);
	--_parsingDepth;
}
\`\`\`
`,
block173 : `### block 173 : 2601 - 2628

\`\`\`cpp
XMLPrinter::XMLPrinter( FILE* file, bool compact, int depth, EscapeAposCharsInAttributes aposInAttributes ) :
    _elementJustOpened( false ),
    _stack(),
    _firstElement( true ),
    _fp( file ),
    _depth( depth ),
    _textDepth( -1 ),
    _processEntities( true ),
    _compactMode( compact ),
    _buffer()
{
    for( int i=0; i<ENTITY_RANGE; ++i ) {
        _entityFlag[i] = false;
        _restrictedEntityFlag[i] = false;
    }
    for( int i=0; i<NUM_ENTITIES; ++i ) {
        const char entityValue = entities[i].value;
        if ((aposInAttributes == ESCAPE_APOS_CHARS_IN_ATTRIBUTES) || (entityValue != SINGLE_QUOTE)) {
            const unsigned char flagIndex = static_cast<unsigned char>(entityValue);
            TIXMLASSERT( flagIndex < ENTITY_RANGE );
            _entityFlag[flagIndex] = true;
        }
    }
    _restrictedEntityFlag[static_cast<unsigned char>('&')] = true;
    _restrictedEntityFlag[static_cast<unsigned char>('<')] = true;
    _restrictedEntityFlag[static_cast<unsigned char>('>')] = true;	// not required, but consistency is nice
    _buffer.Push( 0 );
}
\`\`\`
`,
block174 : `### block 174 : 2631 - 2650

\`\`\`cpp
void XMLPrinter::Print( const char* format, ... )
{
    va_list     va;
    va_start( va, format );

    if ( _fp ) {
        vfprintf( _fp, format, va );
    }
    else {
        const int len = TIXML_VSCPRINTF( format, va );
        // Close out and re-start the va-args
        va_end( va );
        TIXMLASSERT( len >= 0 );
        va_start( va, format );
        TIXMLASSERT( _buffer.Size() > 0 && _buffer[_buffer.Size() - 1] == 0 );
        char* p = _buffer.PushArr( len ) - 1;	// back up over the null terminator.
		TIXML_VSNPRINTF( p, len+1, format, va );
    }
    va_end( va );
}
\`\`\`
`,
block175 : `### block 175 : 2653 - 2663

\`\`\`cpp
void XMLPrinter::Write( const char* data, size_t size )
{
    if ( _fp ) {
        fwrite ( data , sizeof(char), size, _fp);
    }
    else {
        char* p = _buffer.PushArr( size ) - 1;   // back up over the null terminator.
        memcpy( p, data, size );
        p[size] = 0;
    }
}
\`\`\`
`,
block176 : `### block 176 : 2666 - 2676

\`\`\`cpp
void XMLPrinter::Putc( char ch )
{
    if ( _fp ) {
        fputc ( ch, _fp);
    }
    else {
        char* p = _buffer.PushArr( sizeof(char) ) - 1;   // back up over the null terminator.
        p[0] = ch;
        p[1] = 0;
    }
}
\`\`\`
`,
block177 : `### block 177 : 2679 - 2684

\`\`\`cpp
void XMLPrinter::PrintSpace( int depth )
{
    for( int i=0; i<depth; ++i ) {
        Write( "    " );
    }
}
\`\`\`
`,
block178 : `### block 178 : 2687 - 2739

\`\`\`cpp
void XMLPrinter::PrintString( const char* p, bool restricted )
{
    // Look for runs of bytes between entities to print.
    const char* q = p;

    if ( _processEntities ) {
        const bool* flag = restricted ? _restrictedEntityFlag : _entityFlag;
        while ( *q ) {
            TIXMLASSERT( p <= q );
            // Remember, char is sometimes signed. (How many times has that bitten me?)
            if ( *q > 0 && *q < ENTITY_RANGE ) {
                // Check for entities. If one is found, flush
                // the stream up until the entity, write the
                // entity, and keep looking.
                if ( flag[static_cast<unsigned char>(*q)] ) {
                    while ( p < q ) {
                        const size_t delta = q - p;
                        const int toPrint = ( INT_MAX < delta ) ? INT_MAX : static_cast<int>(delta);
                        Write( p, toPrint );
                        p += toPrint;
                    }
                    bool entityPatternPrinted = false;
                    for( int i=0; i<NUM_ENTITIES; ++i ) {
                        if ( entities[i].value == *q ) {
                            Putc( '&' );
                            Write( entities[i].pattern, entities[i].length );
                            Putc( ';' );
                            entityPatternPrinted = true;
                            break;
                        }
                    }
                    if ( !entityPatternPrinted ) {
                        // TIXMLASSERT( entityPatternPrinted ) causes gcc -Wunused-but-set-variable in release
                        TIXMLASSERT( false );
                    }
                    ++p;
                }
            }
            ++q;
            TIXMLASSERT( p <= q );
        }
        // Flush the remaining string. This will be the entire
        // string if an entity wasn't found.
        if ( p < q ) {
            const size_t delta = q - p;
            const int toPrint = ( INT_MAX < delta ) ? INT_MAX : static_cast<int>(delta);
            Write( p, toPrint );
        }
    }
    else {
        Write( p );
    }
}
\`\`\`
`,
block179 : `### block 179 : 2742 - 2751

\`\`\`cpp
void XMLPrinter::PushHeader( bool writeBOM, bool writeDec )
{
    if ( writeBOM ) {
        static const unsigned char bom[] = { TIXML_UTF_LEAD_0, TIXML_UTF_LEAD_1, TIXML_UTF_LEAD_2, 0 };
        Write( reinterpret_cast< const char* >( bom ) );
    }
    if ( writeDec ) {
        PushDeclaration( "xml version=\"1.0\"" );
    }
}
\`\`\`
`,
block180 : `### block 180 : 2753 - 2769

\`\`\`cpp
void XMLPrinter::PrepareForNewNode( bool compactMode )
{
    SealElementIfJustOpened();

    if ( compactMode ) {
        return;
    }

    if ( _firstElement ) {
        PrintSpace (_depth);
    } else if ( _textDepth < 0) {
        Putc( '\n' );
        PrintSpace( _depth );
    }

    _firstElement = false;
}
\`\`\`
`,
block181 : `### block 181 : 2771 - 2781

\`\`\`cpp
void XMLPrinter::OpenElement( const char* name, bool compactMode )
{
    PrepareForNewNode( compactMode );
    _stack.Push( name );

    Write ( "<" );
    Write ( name );

    _elementJustOpened = true;
    ++_depth;
}
\`\`\`
`,
block182 : `### block 182 : 2784 - 2792

\`\`\`cpp
void XMLPrinter::PushAttribute( const char* name, const char* value )
{
    TIXMLASSERT( _elementJustOpened );
    Putc ( ' ' );
    Write( name );
    Write( "=\"" );
    PrintString( value, false );
    Putc ( '\"' );
}
\`\`\`
`,
block183 : `### block 183 : 2795 - 2800

\`\`\`cpp
void XMLPrinter::PushAttribute( const char* name, int v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    PushAttribute( name, buf );
}
\`\`\`
`,
block184 : `### block 184 : 2803 - 2808

\`\`\`cpp
void XMLPrinter::PushAttribute( const char* name, unsigned v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    PushAttribute( name, buf );
}
\`\`\`
`,
block185 : `### block 185 : 2811 - 2816

\`\`\`cpp
void XMLPrinter::PushAttribute(const char* name, int64_t v)
{
	char buf[BUF_SIZE];
	XMLUtil::ToStr(v, buf, BUF_SIZE);
	PushAttribute(name, buf);
}
\`\`\`
`,
block186 : `### block 186 : 2819 - 2824

\`\`\`cpp
void XMLPrinter::PushAttribute(const char* name, uint64_t v)
{
	char buf[BUF_SIZE];
	XMLUtil::ToStr(v, buf, BUF_SIZE);
	PushAttribute(name, buf);
}
\`\`\`
`,
block187 : `### block 187 : 2827 - 2832

\`\`\`cpp
void XMLPrinter::PushAttribute( const char* name, bool v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    PushAttribute( name, buf );
}
\`\`\`
`,
block188 : `### block 188 : 2835 - 2840

\`\`\`cpp
void XMLPrinter::PushAttribute( const char* name, double v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    PushAttribute( name, buf );
}
\`\`\`
`,
block189 : `### block 189 : 2843 - 2868

\`\`\`cpp
void XMLPrinter::CloseElement( bool compactMode )
{
    --_depth;
    const char* name = _stack.Pop();

    if ( _elementJustOpened ) {
        Write( "/>" );
    }
    else {
        if ( _textDepth < 0 && !compactMode) {
            Putc( '\n' );
            PrintSpace( _depth );
        }
        Write ( "</" );
        Write ( name );
        Write ( ">" );
    }

    if ( _textDepth == _depth ) {
        _textDepth = -1;
    }
    if ( _depth == 0 && !compactMode) {
        Putc( '\n' );
    }
    _elementJustOpened = false;
}
\`\`\`
`,
block190 : `### block 190 : 2871 - 2878

\`\`\`cpp
void XMLPrinter::SealElementIfJustOpened()
{
    if ( !_elementJustOpened ) {
        return;
    }
    _elementJustOpened = false;
    Putc( '>' );
}
\`\`\`
`,
block191 : `### block 191 : 2881 - 2894

\`\`\`cpp
void XMLPrinter::PushText( const char* text, bool cdata )
{
    _textDepth = _depth-1;

    SealElementIfJustOpened();
    if ( cdata ) {
        Write( "<![CDATA[" );
        Write( text );
        Write( "]]>" );
    }
    else {
        PrintString( text, true );
    }
}
\`\`\`
`,
block192 : `### block 192 : 2897 - 2902

\`\`\`cpp
void XMLPrinter::PushText( int64_t value )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( value, buf, BUF_SIZE );
    PushText( buf, false );
}
\`\`\`
`,
block193 : `### block 193 : 2905 - 2910

\`\`\`cpp
void XMLPrinter::PushText( uint64_t value )
{
	char buf[BUF_SIZE];
	XMLUtil::ToStr(value, buf, BUF_SIZE);
	PushText(buf, false);
}
\`\`\`
`,
block194 : `### block 194 : 2913 - 2918

\`\`\`cpp
void XMLPrinter::PushText( int value )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( value, buf, BUF_SIZE );
    PushText( buf, false );
}
\`\`\`
`,
block195 : `### block 195 : 2921 - 2926

\`\`\`cpp
void XMLPrinter::PushText( unsigned value )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( value, buf, BUF_SIZE );
    PushText( buf, false );
}
\`\`\`
`,
block196 : `### block 196 : 2929 - 2934

\`\`\`cpp
void XMLPrinter::PushText( bool value )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( value, buf, BUF_SIZE );
    PushText( buf, false );
}
\`\`\`
`,
block197 : `### block 197 : 2937 - 2942

\`\`\`cpp
void XMLPrinter::PushText( float value )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( value, buf, BUF_SIZE );
    PushText( buf, false );
}
\`\`\`
`,
block198 : `### block 198 : 2945 - 2950

\`\`\`cpp
void XMLPrinter::PushText( double value )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( value, buf, BUF_SIZE );
    PushText( buf, false );
}
\`\`\`
`,
block199 : `### block 199 : 2953 - 2960

\`\`\`cpp
void XMLPrinter::PushComment( const char* comment )
{
    PrepareForNewNode( _compactMode );

    Write( "<!--" );
    Write( comment );
    Write( "-->" );
}
\`\`\`
`,
block200 : `### block 200 : 2963 - 2970

\`\`\`cpp
void XMLPrinter::PushDeclaration( const char* value )
{
    PrepareForNewNode( _compactMode );

    Write( "<?" );
    Write( value );
    Write( "?>" );
}
\`\`\`
`,
block201 : `### block 201 : 2973 - 2980

\`\`\`cpp
void XMLPrinter::PushUnknown( const char* value )
{
    PrepareForNewNode( _compactMode );

    Write( "<!" );
    Write( value );
    Putc( '>' );
}
\`\`\`
`,
block202 : `### block 202 : 2983 - 2990

\`\`\`cpp
bool XMLPrinter::VisitEnter( const XMLDocument& doc )
{
    _processEntities = doc.ProcessEntities();
    if ( doc.HasBOM() ) {
        PushHeader( true, false );
    }
    return true;
}
\`\`\`
`,
block203 : `### block 203 : 2993 - 3006

\`\`\`cpp
bool XMLPrinter::VisitEnter( const XMLElement& element, const XMLAttribute* attribute )
{
    const XMLElement* parentElem = 0;
    if ( element.Parent() ) {
        parentElem = element.Parent()->ToElement();
    }
    const bool compactMode = parentElem ? CompactMode( *parentElem ) : _compactMode;
    OpenElement( element.Name(), compactMode );
    while ( attribute ) {
        PushAttribute( attribute->Name(), attribute->Value() );
        attribute = attribute->Next();
    }
    return true;
}
\`\`\`
`,
block204 : `### block 204 : 3009 - 3013

\`\`\`cpp
bool XMLPrinter::VisitExit( const XMLElement& element )
{
    CloseElement( CompactMode(element) );
    return true;
}
\`\`\`
`,
block205 : `### block 205 : 3016 - 3020

\`\`\`cpp
bool XMLPrinter::Visit( const XMLText& text )
{
    PushText( text.Value(), text.CData() );
    return true;
}
\`\`\`
`,
block206 : `### block 206 : 3023 - 3027

\`\`\`cpp
bool XMLPrinter::Visit( const XMLComment& comment )
{
    PushComment( comment.Value() );
    return true;
}
\`\`\`
`,
block207 : `### block 207 : 3029 - 3033

\`\`\`cpp
bool XMLPrinter::Visit( const XMLDeclaration& declaration )
{
    PushDeclaration( declaration.Value() );
    return true;
}
\`\`\`
`,
block208 : `### block 208 : 3036 - 3040

\`\`\`cpp
bool XMLPrinter::Visit( const XMLUnknown& unknown )
{
    PushUnknown( unknown.Value() );
    return true;
}
\`\`\`
`
        };

        const blockExplainContents = {
            block1 : `### block 1

- TinyXML2是一个轻量级、高效且易于使用的C++ XML解析库，专为嵌入式系统和小型项目设计。它采用DOM（文档对象模型）方式解析XML文档，支持读取、修改和保存XML数据，具有极小的内存占用和简洁的API接口。
- TinyXML2仅需一个头文件（tinyxml2.h）和一个源文件（tinyxml2.cpp）即可集成，无需依赖复杂的外部框架或STL，整体体积小巧，不会显著增加项目编译后的文件大小。

---

### **基本使用**​：

\`\`\`
#include "tinyxml2.h"
using namespace tinyxml2;

int main() {
    XMLDocument doc;
    doc.LoadFile("example.xml");
    
    // 获取根元素
    XMLElement* root = doc.RootElement();
    
    // 读取元素属性
    const char* name = root->Attribute("Name");
    
    // 读取文本内容
    const char* text = root->GetText();
    
    return 0;
}
\`\`\`

---

### tinyxml2几个关键的设计思想：

1. ​**统一的节点模型**​：​**XMLNode**​ 作为所有XML组件的基类，定义了它们在DOM树中的基本连接关系（父节点、首个子节点、兄弟节点等）和通用操作（如遍历、插入）。这种设计使得处理不同类型的节点（如元素、注释、文本）可以使用统一的接口，简化了代码。
    
2. ​**严格的内存管理**​：​**XMLDocument**​ 不仅是文档的根节点，更扮演着**工厂角色**和**内存管理器**的角色。所有节点对象都必须通过它的 \`NewElement()\`, \`NewText()\` 等方法创建。这些对象由文档内部的内存池（如 \`_elementPool\`）统一管理，当 \`XMLDocument\` 析构时，所有节点内存会被自动清理，有效防止了内存泄漏。
    
3. ​**清晰的职责分离**​：
    
    - \`XMLElement\` 负责处理标签名、属性和文本内容（通过子节点获取）。
    - \`XMLAttribute\` 独立封装了属性的键值对，并通过链表结构连接，与元素的子节点模型分离开。
    - 其他如 \`XMLText\`、\`XMLComment\` 等类各司其职，专门处理特定类型的XML内容。

`,
block2 : `### block 2


- ​**使用安全函数**​：代码明确选择了 vsnprintf_s 这个更安全的函数版本，该函数要求指定缓冲区大小，能有效防止缓冲区溢出 。
- ​**_TRUNCATE 参数**​：_TRUNCATE 是一个重要的安全标志。它告诉函数，如果输出内容超过缓冲区大小，则进行截断并确保字符串以空字符（\`\0\`）结尾，而不是直接导致错误或崩溃。这比不检查边界或直接返回错误更适用于需要稳健运行的库代码 。
`,
block3 : `### block 3

`,
block4 : `### block 4

`,
block5 : `### block 5

`,
block6 : `### block 6

`,
block7 : `### block 7

`,
block8 : `### block 8

`,
block9 : `### block 9

`,
block10 : `### block 10

`,
block11 : `### block 11

`,
block12 : `### block 12

`,
block13 : `### block 13

`,
block14 : `### block 14

`,
block15 : `### block 15

`,
block16 : `### block 16

`,
block17 : `### block 17

`,
block18 : `### block 18

`,
block19 : `### block 19

`,
block20 : `### block 20

`,
block21 : `### block 21

`,
block22 : `### block 22

`,
block23 : `### block 23

`,
block24 : `### block 24

`,
block25 : `### block 25

`,
block26 : `### block 26

`,
block27 : `### block 27

`,
block28 : `### block 28

`,
block29 : `### block 29

`,
block30 : `### block 30

`,
block31 : `### block 31

`,
block32 : `### block 32

`,
block33 : `### block 33

`,
block34 : `### block 34

`,
block35 : `### block 35

`,
block36 : `### block 36

`,
block37 : `### block 37

`,
block38 : `### block 38

`,
block39 : `### block 39

`,
block40 : `### block 40

`,
block41 : `### block 41

`,
block42 : `### block 42

`,
block43 : `### block 43

`,
block44 : `### block 44

`,
block45 : `### block 45

`,
block46 : `### block 46

`,
block47 : `### block 47

`,
block48 : `### block 48

`,
block49 : `### block 49

`,
block50 : `### block 50

`,
block51 : `### block 51

`,
block52 : `### block 52

`,
block53 : `### block 53

`,
block54 : `### block 54

`,
block55 : `### block 55

`,
block56 : `### block 56

`,
block57 : `### block 57

`,
block58 : `### block 58

`,
block59 : `### block 59

`,
block60 : `### block 60

`,
block61 : `### block 61

`,
block62 : `### block 62

`,
block63 : `### block 63

`,
block64 : `### block 64

`,
block65 : `### block 65

`,
block66 : `### block 66

`,
block67 : `### block 67

`,
block68 : `### block 68

`,
block69 : `### block 69

`,
block70 : `### block 70

`,
block71 : `### block 71

`,
block72 : `### block 72

`,
block73 : `### block 73

`,
block74 : `### block 74

`,
block75 : `### block 75

`,
block76 : `### block 76

`,
block77 : `### block 77

`,
block78 : `### block 78

`,
block79 : `### block 79

`,
block80 : `### block 80

`,
block81 : `### block 81

`,
block82 : `### block 82

`,
block83 : `### block 83

`,
block84 : `### block 84

`,
block85 : `### block 85

`,
block86 : `### block 86

`,
block87 : `### block 87

`,
block88 : `### block 88

`,
block89 : `### block 89

`,
block90 : `### block 90

`,
block91 : `### block 91

`,
block92 : `### block 92

`,
block93 : `### block 93

`,
block94 : `### block 94

`,
block95 : `### block 95

`,
block96 : `### block 96

`,
block97 : `### block 97

`,
block98 : `### block 98

`,
block99 : `### block 99

`,
block100 : `### block 100

`,
block101 : `### block 101

`,
block102 : `### block 102

`,
block103 : `### block 103

`,
block104 : `### block 104

`,
block105 : `### block 105

`,
block106 : `### block 106

`,
block107 : `### block 107

`,
block108 : `### block 108

`,
block109 : `### block 109

`,
block110 : `### block 110

`,
block111 : `### block 111

`,
block112 : `### block 112

`,
block113 : `### block 113

`,
block114 : `### block 114

`,
block115 : `### block 115

`,
block116 : `### block 116

`,
block117 : `### block 117

`,
block118 : `### block 118

`,
block119 : `### block 119

`,
block120 : `### block 120

`,
block121 : `### block 121

`,
block122 : `### block 122

`,
block123 : `### block 123

`,
block124 : `### block 124

`,
block125 : `### block 125

`,
block126 : `### block 126

`,
block127 : `### block 127

`,
block128 : `### block 128

`,
block129 : `### block 129

`,
block130 : `### block 130

`,
block131 : `### block 131

`,
block132 : `### block 132

`,
block133 : `### block 133

`,
block134 : `### block 134

`,
block135 : `### block 135

`,
block136 : `### block 136

`,
block137 : `### block 137

`,
block138 : `### block 138

`,
block139 : `### block 139

`,
block140 : `### block 140

`,
block141 : `### block 141

`,
block142 : `### block 142

`,
block143 : `### block 143

`,
block144 : `### block 144

`,
block145 : `### block 145

`,
block146 : `### block 146

`,
block147 : `### block 147

`,
block148 : `### block 148

`,
block149 : `### block 149

`,
block150 : `### block 150

`,
block151 : `### block 151

`,
block152 : `### block 152

`,
block153 : `### block 153

`,
block154 : `### block 154

`,
block155 : `### block 155

`,
block156 : `### block 156

`,
block157 : `### block 157

`,
block158 : `### block 158

`,
block159 : `### block 159

`,
block160 : `### block 160

`,
block161 : `### block 161

`,
block162 : `### block 162

`,
block163 : `### block 163

`,
block164 : `### block 164

`,
block165 : `### block 165

`,
block166 : `### block 166

`,
block167 : `### block 167

`,
block168 : `### block 168

`,
block169 : `### block 169

`,
block170 : `### block 170

`,
block171 : `### block 171

`,
block172 : `### block 172

`,
block173 : `### block 173

`,
block174 : `### block 174

`,
block175 : `### block 175

`,
block176 : `### block 176

`,
block177 : `### block 177

`,
block178 : `### block 178

`,
block179 : `### block 179

`,
block180 : `### block 180

`,
block181 : `### block 181

`,
block182 : `### block 182

`,
block183 : `### block 183

`,
block184 : `### block 184

`,
block185 : `### block 185

`,
block186 : `### block 186

`,
block187 : `### block 187

`,
block188 : `### block 188

`,
block189 : `### block 189

`,
block190 : `### block 190

`,
block191 : `### block 191

`,
block192 : `### block 192

`,
block193 : `### block 193

`,
block194 : `### block 194

`,
block195 : `### block 195

`,
block196 : `### block 196

`,
block197 : `### block 197

`,
block198 : `### block 198

`,
block199 : `### block 199

`,
block200 : `### block 200

`,
block201 : `### block 201

`,
block202 : `### block 202

`,
block203 : `### block 203

`,
block204 : `### block 204

`,
block205 : `### block 205

`,
block206 : `### block 206

`,
block207 : `### block 207

`,
block208 : `### block 208

`
        };

        // 获取blockCodeContents的item大小
        const blockCodeContentsSize = Object.keys(blockCodeContents).length;
        console.log('blockCodeContents的item大小:', blockCodeContentsSize);


        // 页面加载完成后，使用marked.parse将代码和解释写入到对应的div中
        window.addEventListener('DOMContentLoaded', function() {
            // 使用循环写入所有代码块和解释块内容，循环上限使用blockCodeContents的实际大小
            for (let i = 1; i <= blockCodeContentsSize; i++) {
                const blockId = `block${i}`;
                const explainBlockId = `explainBlock${i}`;

                // 写入代码块内容
                document.getElementById(blockId).querySelector('.code-content').innerHTML = marked.parse(blockCodeContents[blockId]);

                // 写入解释块内容
                document.getElementById(explainBlockId).querySelector('.explain-content').innerHTML = marked.parse(blockExplainContents[blockId]);
            }
        });

        const codeColumn = document.getElementById('codeColumn');
    codeColumn.addEventListener('scroll', () => {
        let active = null;
        document.querySelectorAll('.code-block').forEach(block => {
            const rect = block.getBoundingClientRect();
            if (rect.top <= 200 && rect.bottom >= 200) active = block;
        });
        document.querySelectorAll('.code-block, .explain-block').forEach(el => el.classList.remove('active'));
        if (active) {
            active.classList.add('active');
            document.querySelector(`.explain-block[data-id="${active.dataset.id}"]`).classList.add('active');
        }
    });

    document.getElementById('saveButton').addEventListener('click', function() {
        const htmlContent = document.documentElement.outerHTML;
        const blob = new Blob([htmlContent], { type: 'text/html' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        const currentPath = window.location.pathname;
        const originalFileName = currentPath.split(/[\\/]/).pop();
        const fileName = originalFileName
                             ? (originalFileName.endsWith('.html') ? originalFileName : `${originalFileName}.html`)
                             : 'code_notes.html';
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);

        this.textContent = 'save success';
        setTimeout(() => this.textContent = 'save context', 1500);
    });
    </script>
        </body>
        </html>